Java 基础

## JDK 和 JRE 有什么区别？

**JRE（Java Runtime Environment）：**

​	包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的，还有所有的Java类库的class文件，都在lib目录下，并且都打包成了jar。

**JDK(Java Development Kit)：**

​	是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。

JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。

简单来说，JRE可以支撑Java程序的运行，包括JVM虚拟机（java.exe等）和基本的类库（rt.jar等），JDK可以支持Java程序的开发，包括编译器（javac.exe）、开发工具（javadoc.exe、jar.exe、keytool.exe、jconsole.exe）和更多的类库（如tools.jar）等。

 

## == 和 equals 的区别是什么？

**Java数据类型分为：**

　　　　　　　　　基本数据类型

　　　　　　　　　复合数据类型（包装类是基本数据类型的引用类型也属于复合数据类型）

**基本数据类型：**

　　　　　　byte，short，int，long，float，double，char，boolean 

**复合数据类型：**

　　　　　　　包装类：Byte ,Short,Integer,Long,Float,Double,Character,Boolean

　　　　　　　对象：var obj ={"name":"xiaoming"}

　　　　　　　数组: var objarr = ["1","2","3"]

　　　　　　　函数:function f(){}

1）基本数据类型之间比较用 == 且比较值，而复合数据类型 == 比较的时候两对象的地址值是否一致，所以除非是同一个new出来的对象，结果为true，否则为false。

2）对于equals() 由于java中所有类都继承与Object基类，在Object类中定义了一个equals()，该方法初始化是比较对象的内存地址。



但在一些类中重写了这个方法，如包装类String,Date等，equals()比较的是两个变量的值。

String

创建String对象的两种方式比较他们的==和equals会有不同的效果

```Java
String s1=”sss”;
String s2=new String(“sss”);
System.out.println(s1==s2);//false
System.out.println(s1.equals(s2));//true
```



研究这个结果就需要了解一下String对象的创建机制。

String s1=”sss”;这种创建方式在内存中的过程是在***方法区的常量池中创建一个”sss”字面值*** ，然后之后由这种创建方式的变量都由栈中指向这个地址，所以只要值一样，变量之间==为true;

而String s2=new String(“sss”);这种创建方式的过程具体是在***堆中创建一个新的对象***，所以在和值一样的变量比较==时为false，但是只要值一样的话.equals()还是为true的。

String中还有个特殊的地方就是使用**+号拼接得到的结果**：

如果值和某变量值一致，不代表两变量地址一致，

​	如果拼接的是一个字面值，则指向同一个值的常量池地址，两变量地址一致。
​	但如果拼接的是一个变量相当于新建了一个对象，地址指向堆，所以即使值一致，地址也不一样。	

```Java
String a = "ab";
String b = "a" + "b";
String c = "a";
String d = c + "b";
System.out.println(a == b);//true
System.out.println(a == d);//false
```



String中有个**intern()**方法。

 这个方法的作用是**在常量池中检查是否有和该字符串相同的值，如果有，则返回常量值，若没有就创建该常量值，并返回。所以通过intern()得到的值会和指向同一个常量池值的变量地址一致且值一致**

```java
String a = "ab";
String c = "a";
String d = c + "b"
String intern = d.intern();
System.out.println(intern == d);//false
System.out.println(intern == a);//true
```

针对String简单的总结一下：

①只要不新建对象，值相同地址一般相等

②String身为一个不可变值，对字符串的操作会新建一个对象。

③拼接时关注字符串是否新建对象





·包装类

当包装类和基本类型**进行”==”比较时，包装类会自动拆箱为基本数据类型再进行比较**。而字面值的地址都指向常量池，值相同地址相同。

两个相同包装类型的对象**进行equals()比较时，equals()会先比较类型，如果类型相同再比较值，二者同时成立为true**，**包装类调用equals()，但是参数是基本类型，这时候会先进行自动装箱，基本类型转换为其包装类，先判断类型，再判断值，二者都成立时结果为true**

```Java
 int a = 1;
 Integer b = new Integer(1);
 System.out.println(a == b);//true
 System.out.println(b.equals(a));//true
```

两个基本类型没有equals()比较方法；



以Integer为例讨论一下直接赋值的情况下两变量的==结果和equals()值：

因为Integer对象在编译期会自动拆箱（该特性在jdk1.5之后）。

```Java
Integer i1 = 123;
Integer i2 = 123;
System.out.println(i1 == i2);//true
Integer i3 = 200;
Integer i4 = 200;
System.out.println(i3 == i4);//false
Integer i5 = new Integer(123);
System.out.println(i1 == i5);//false
Integer i6 = Integer.valueOf(123);
System.out.println(i1 == i6);//true
```

这个记过就很神奇，和上一个例子明明一样为什么结果不一样。这是因为Integer自动拆箱的过程：Integer i1=200在编译期会调用一个叫valueOf()的静态方法

```Java
  public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

由此可知，cache是一个数组，规定了整型在[-127,128]这个范围。超过这个范围的值就会在堆内存中创建一个新的对象，两对象地址不同。

运行时常量池会放入：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）

针对Integer简单总结一下：

①无论如何Integer变量不会和新创建的对象相等。

②Integer在==比较时会在编译时期自动拆箱。



## 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

```JAVA
 Person person = new Person();
        System.out.println(person);//com.example.demo.test.equals_hascode.Person@28ba21f3
        System.out.println(person.getClass().getName()+"@"+Integer.toHexString(person.hashCode()));//com.example.demo.test.equals_hascode.Person@28ba21f3
```

hashCode（)内存中编号，方便寻址；

- 哈希函数、散列函数；

- 单向函数，反向运算无法完成；

- 任意长度输入，固定长度输出；

- 输入不变，输出不变；

- 常见

  - MD5加密+salt

    

关于hashCode和equal是方法是有一些 常规协定 ：

1、两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。
2、两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。
3、重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。



## java 中的 Math.round(-1.5) 等于多少？

Math.round(1.5)的返回值是2，Math.round(-1.5)的返回值是-1。四舍五入的原理是在参数上加0.5然后做向下取整。

## java 中操作字符串都有哪些类？它们之间有什么区别？

String和StringBuffer、StringBuilder；

- String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。

- StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。

- StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。
  不频繁的字符串操作使用 String。反之，StringBuffer 和 StringBuilder 都优于String；

  

## 如何将字符串反转？

方法4  调用StringBuffer中的reverse方法

```java
public static String reverse4(String s) {
  return new StringBuffer(s).reverse().toString();
 }
```

方法5 把字符串转换成字符数组首位对调位置

```Java
public static String reverse5(String orig) {
  char[] s = orig.toCharArray();
  int n = s.length - 1;
  int halfLength = n / 2;
  for (int i = 0; i <= halfLength; i++) {
   char temp = s[i];
   s[i] = s[n - i];
   s[n - i] = temp;
  }
  return new String(s);
 }
```

//方法1 递归方法

```Java
public static String reverse1(String s) {
  int length = s.length();
  if (length <= 1){
     return s;
    }
  String left = s.substring(0, length / 2);
  String right = s.substring(length / 2, length);
  return reverse1(right) + reverse1(left);
 }
```



## String 类的常用方法都有那些？

java.lang.String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。

**String类构造方法**

1. public String(char[] value)
   用字符数组value创建一个String对象。
2. public String(char chars[], int startIndex, int numChars)
   用字符数组chars的startIndex开始的numChars个字符创建一个String对象。
3. public String(byte[] values)
   用比特数组values创建一个String对象。

**String类常用方法**

1. 求字符串长度；

2. 求字符串某一位置字符；

   **public char charAt(int index)**//返回字符串中指定位置的字符；

   注意字符串中第一个字符索引是0，最后一个是length()-1。

   ```java
   String str = new String("asdfzxc");
   char ch = str.charAt(4);//ch = z
   ```

3. 提取子串；

   ```java
   1 String str1 = new String("asdfzxc");
   2 String str2 = str1.substring(2);//str2 = "dfzxc"
   3 String str3 = str1.substring(2,5);//str3 = "dfz"
   ```

4. 字符串比较
   对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。

   ```java
   String str1 = new String("abc");
   String str2 = new String("ABC");
   int a = str1.compareTo(str2);//a>0
   int b = str1.compareToIgnoreCase(str2);//b=0
   boolean c = str1.equals(str2);//c=false
   boolean d = str1.equalsIgnoreCase(str2);//d=true
   ```

   **regionMatches(boolean b, int firstStart, String other, int otherStart, int length)**
   从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。

   ```java
   String str1 = new String("abc");
   String str2 = new String("ABC");
   System.out.println(str1.regionMatches(true, 0, str2, 0, 3));//true
   System.out.println(str1.regionMatches(false, 0, str2, 0, 3));//false
   System.out.println(str1.regionMatches(true, 0, str2, 1, 3));//false
   System.out.println(str1.regionMatches(0, str2.toLowerCase(), 0, 3));//true
   ```

5. 字符串连接

   ```JAVA
   1 String str = "aa".concat("bb").concat("cc");
   2 相当于String str = "aa"+"bb"+"cc";
   ```

6. 字符串中单个字符查找（各个字符位置索引固定，规则查找匹配到的字符）

   ```JAVA
   String str = "I am a good student";
   int a = str.indexOf('a');//a = 2
   int b = str.indexOf("good");//b = 7
   int c = str.indexOf("w",2);//c = -1
   int d = str.lastIndexOf("a");//d = 5 从后向前查找遇到第一个a的位置
   int e = str.lastIndexOf("a",3);//e = 2 指定位置从后向前，遇到第一个a的位置
   ```

7. 字符串中字符的大小写转换

   ```JAVA
   1 String str = new String("asDF");
   2 String str1 = str.toLowerCase();//str1 = "asdf"
   3 String str2 = str.toUpperCase();//str2 = "ASDF"
   ```

8. 字符串中字符的替换

   ```JAVA
   1 String str = "asdzxcasd";
   2 String str1 = str.replace('a','g');//str1 = "gsdzxcgsd"
   3 String str2 = str.replace("asd","fgh");//str2 = "fghzxcfgh"
   4 String str3 = str.replaceFirst("asd","fgh");//str3 = "fghzxcasd"
   5 String str4 = str.replaceAll("asd","fgh");//str4 = "fghzxcfgh"
   ```

9. 截取空格（只能截取首尾空格）

   ```java
   1 String str = " a sd ";
   2 String str1 = str.trim();
   3 int a = str.length();//a = 6
   4 int b = str1.length();//b = 4
   ```

10. 判断首位字符

    ```java
    1 String str = "asdfgh";
    2 boolean a = str.statWith("as");//a = true
    3 boolean b = str.endWith("gh");//b = true
    ```

11. 是否包含子串

    ```java
    1 String str = "student";
    2 str.contains("stu");//true
    3 str.contains("ok");//false
    ```

12. 分解成数组

    ```
    1 String str = "asd!qwe|zxc#";
    2 String[] str1 = str.split("!|#");//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc"
    ```

    

**字符串与基本类型的转换**

1、字符串转换为基本类型
java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：
1)public static byte parseByte(String s)
2)public static short parseShort(String s)
3)public static short parseInt(String s)
4)public static long parseLong(String s)
5)public static float parseFloat(String s)
6)public static double parseDouble(String s)
例如：

```java
1 int n = Integer.parseInt("12");
2 float f = Float.parseFloat("12.34");
3 double d = Double.parseDouble("1.124");
```

2、基本类型转换为字符串类型
String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。
1)static String valueOf(char data[])
2)static String valueOf(char data[], int offset, int count)
3)static String valueOf(boolean b)
4)static String valueOf(char c)
5)static String valueOf(int i)
6)static String valueOf(long l)
7)static String valueOf(float f)
8)static String valueOf(double d)
例如：

```java
1 String s1 = String.valueOf(12);
2 String s1 = String.valueOf(12.34);
```

3、进制转换
使用Long类中的方法得到整数之间的各种进制转换的方法：
Long.toBinaryString(long l)
Long.toOctalString(long l)
Long.toHexString(long l)
Long.toString(long l, int p)//p作为任意进制



## 抽象类必须要有抽象方法吗？

## 普通类和抽象类有哪些区别？

## 抽象类能使用 final 修饰吗？

不能； 

## 接口和抽象类有什么区别？

## java 中 IO 流分为几种？

## BIO、NIO、AIO 有什么区别？

## Files的常用方法都有哪些？

# 二、容器

## java 容器都有哪些？

## Collection 和 Collections 有什么区别？

## List、Set、Map 之间的区别是什么？

## HashMap 和 Hashtable 有什么区别？

## 如何决定使用 HashMap 还是 TreeMap？

## 说一下 HashMap 的实现原理？

## 说一下 HashSet 的实现原理？

## ArrayList 和 LinkedList 的区别是什么？

## 如何实现数组和 List 之间的转换？

## ArrayList 和 Vector 的区别是什么？

## Array 和 ArrayList 有何区别？

## 在 Queue 中 poll()和 remove()有什么区别？

## 哪些集合类是线程安全的？

## 迭代器 Iterator 是什么？

## Iterator 怎么使用？有什么特点？

## Iterator 和 ListIterator 有什么区别？

## 怎么确保一个集合不能被修改？

# 三、多线程

## 并行和并发有什么区别？

并发是多线程中的名词，多线程发生的过程是：多线程是通过线程轮流切换来获取CPU执行时间的；

一、区别：

并发是指一个处理器同时处理多个任务。 
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 
并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 

二、图解：

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。 

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825164818667-2129927824.png)

 

并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825164935572-1875514223.png)

并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

三、在一个CPU或多个CPU的情况下：

当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。

当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825165218443-1602996394.png)





## 线程和进程的区别？

1. 进程是**资源分配**的最小单位，线程是**程序执行**的最小单位（资源调度的最小单位）；
2. 进程有自己的**独立地址空间**，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
3. 线程是**共享进程中的数据**的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
4. **线程之间的通信更方便**，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
5. **多进程程序更健壮**，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间；



## 守护线程是什么？

java里线程分2种：

用户线程：应用程序里的线程，一般都是用户自定义线程；

守护线程（即daemon thread），专门用于服务其他的线程的线程，比如**垃圾回收线程**，就是最典型的守护线程。

1、守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。

 2、再换一种说法，如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。

 3、守护线程又被称为“服务进程”“精灵线程”“后台线程”，是指在程序运行是在后台提供一种通用的线程，这种线程并不属于程序不可或缺的部分。 通俗点讲，**任何一个守护线程都是整个JVM中所有非守护线程的“保姆”**。



## 创建线程有哪几种方式？

Java中创建线程主要有三种方式：

一、继承Thread类创建线程类

（1）定义**Thread类的子类**，重写run方法，run()方法称为执行体。

（2）创建Thread子类的实例，即创建了线程对象。

（3）调用线程对象的**start()**方法来启动该线程。

```Java
public class FirstThreadTest extends Thread {

    int i = 0;

    //重写run方法，run方法的方法体就是现场执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }

    public static void main(String[] args) {

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

二、通过Runnable接口创建线程类

 （1）定义**runnable接口实现类**，**重写run()**方法，该run()方法的方法体同样是该线程的线程执行体。

 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

 （3）调用线程对象的**start()**方法来启动该线程。

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

三、通过Callable和Future创建线程

 （1）创建**Callable接口的实现类**，并实现**call()**方法，该call()方法将作为线程执行体，并且有返回值。

 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值；

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }
}
```

**采用实现Runnable、Callable接口的方式创见多线程：**

***优势是：***

 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

 在这种方式下，**多个线程可以共享同一个target对象**，所以非常适合**多个相同线程来处理同一份资源**的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

 ***劣势是：*** 

编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

**使用继承Thread类的方式创建多线程时**

***优势是：***

编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

 ***劣势是：***

线程类已经继承了Thread类，所以不能再继承其他父类。

 



## 说一下 runnable 和 callable 有什么区别？

**相同点**：

1. 都是接口
2. 都可以编写多线程程序
3. 都采用Thread.start()启动线程

**不同点**

1. Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果；
2. Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛；

**注**：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。



## 线程有哪些状态？

![img](http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg)



**新建(NEW)**：新创建了一个线程对象。

**可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于*<u>可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</u>*

**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

**阻塞(BLOCKED)**：阻塞状态是指线程<u>因为某种原因放弃了cpu 使用权</u>，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

(一). 等待阻塞：运行(running)的线程执行o<u>.wait()</u>方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该<u>同步锁被别的线程占用</u>，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行<u>Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时</u>，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

**死亡(DEAD)**：线程run()、main() 方法<u>执行结束，或者因异常退出了run()方法</u>，则该线程结束生命周期。死亡的线程不可再次复生。

![img](https://images2015.cnblogs.com/blog/987722/201610/987722-20161023195546779-1879243475.png)



## sleep() 和 wait() 有什么区别？

## notify()和 notifyAll()有什么区别？

## 线程的 run()和 start()有什么区别？

run()相当于线程的任务处理逻辑的入口方法，它由**Java虚拟机在运行相应线程时直接调用**，而不是由应用代码进行调用。每个线程都有要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或通过该方法进行调用。

start()的作用是**启动相应的线程**。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由**线程调度器**决定的。**start()调用结束并不表示相应线程已经开始运行**，这个线程可能稍后运行，也可能永远也不会运行。



## 创建线程池有哪几种方式？

![img](https://images2018.cnblogs.com/blog/683355/201808/683355-20180816144744665-1756137326.png)

各个类型的设计目的：

Executor是一个基础的接口，其初衷是将**任务提交和任务执行细节解耦**，这一点可以参考其定义的唯一方法。

　　void execute(Runnable command);

线程池的好处大致有三种：

1.  降低资源消耗；
2.  提高响应速度；
3.  提高线程的可管理性。使用线程池可以进行资源的统一分配、调优和监控。；

Java通过Executors提供四种线程池，分别为：

1. CachedThreadPool  **可缓存线程池**

   如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，**线程池的容量不限制；**

2. FixedThreadPool  **定长线程池**，

   每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程；
   可控制线程最大并发数，超出的线程会在队列中等待；

3. ScheduledThreadPool **定长线程池**

   定时及周期性任务执行。

4. SingleThreadExecutor **单线程化的线程池**

   单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行；
   例如监听进入的套接字连接的任务；
   对于希望在线程中运行的短任务同样也很方便，例如更新本地或远程日志的小任务，或者是事件分发线程。

5. newSingleThreadScheduledExecutor  **单线程化的线程池**

   单线程可执行周期性任务的线程池；

6. newWorkStealingPool **任务窃取线程池**

   不保证执行顺序，适合任务耗时差异较大。

   线程池中有多个线程队列，有的线程队列中有大量的比较耗时的任务堆积，而有的线程队列却是空的，就存在有的线程处于饥饿状态，当一个线程处于饥饿状态时，它就会去其它的线程队列中窃取任务。解决饥饿导致的效率问题。

   

## 线程池都有哪些状态？

![image](http://images.cnitblog.com/blog/497634/201401/08000847-0a9caed4d6914485b2f56048c668251a.jpg)

1、**RUNNING**

(1) 状态说明：线程池处在RUNNING状态时，**能够接收新任务，以及对已添加的任务进行处理**。 
(2) 状态切换：线程池的**初始化状态**是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

2、 **SHUTDOWN**

(1) 状态说明：线程池处在SHUTDOWN状态时，**不接收新任务，但能处理已添加的任务。** 
(2) 状态切换：调用线程池的**shutdown()**接口时，线程池由RUNNING -> SHUTDOWN。

3、**STOP**

(1) 状态说明：线程池处在STOP状态时，**不接收新任务，不处理已添加的任务，尝试打断正在执行的task
(2) 状态切换：调用线程池的**shutdownNow()**接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、**TIDYING**

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 
(2) 状态切换：当线程池在**SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空**时，就会由 SHUTDOWN -> TIDYING。 
当线程池在**STOP状态下，线程池中执行的任务为空时**，就会由STOP -> TIDYING。

5、 **TERMINATED**

(1) 状态说明：**线程池彻底终止**，就变成TERMINATED状态。 
(2) 状态切换：线程池处在TIDYING状态时，执行完**terminated()**之后，就会由 TIDYING -> TERMINATED。



## 线程池中 submit()和 execute()方法有什么区别？

execute开启线程执行池中的任务；

submit提交指定的任务去执行并且返回Future对象，即执行的结果。
通过捕获Future.get抛出的异常。

```java
package com.example.demo.test.threadpool;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class RunnableTestMain {

    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        /**
         * execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。
         */
        pool.execute(new RunnableTest("Task1"));

        /**
         * submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。
         */
        Future future = pool.submit(new RunnableTest("Task2"));

        try {
            if(future.get()==null){//如果Future's get返回null，任务完成
                System.out.println("任务完成");
            }
        } catch (InterruptedException e) {
        } catch (ExecutionException e) {
            //否则我们可以看看任务失败的原因是什么
            System.out.println(e.getCause().getMessage());
        }
    }
}

class RunnableTest implements Runnable {

    private String taskName;

    public RunnableTest(final String taskName) {
        this.taskName = taskName;
    }

    @Override
    public void run() {
        System.out.println("Inside "+taskName);
        throw new RuntimeException("RuntimeException from inside " + taskName);
    }
}
```





## 在 java 程序中怎么保证多线程的运行安全？

## 多线程锁的升级原理是什么？

## 什么是死锁？

## 怎么防止死锁？

## ThreadLocal 是什么？有哪些使用场景？

## 说一下 synchronized 底层实现原理？

## synchronized 和 volatile 的区别是什么？

## synchronized 和 Lock 有什么区别？

## synchronized 和 ReentrantLock 区别是什么？

## 说一下 atomic 的原理？

# 四、反射

## 什么是反射？

反射指程序可以访问、检测、修改本身状态或行为的一种能力；

反射允许编写与执行时，使程序代码能够接入装载到JVM中类的内部信息；



## 什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成**字节流**的过程。

反序列化：将字节流转换成 Java 对象的过程。

当 Java 对象需要在**网络上传输 或者 持久化存储到文件中**时，就需要对 Java 对象进行序列化处理。

序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

注意事项：

- 某个类可以被序列化，则其子类也可以被序列化；

- 声明为 **static 和 transient 的成员变量，不能被序列化**。static 成员变量是描述类级别的属性，transient 表示临时数据；

- 反序列化读取序列化对象的顺序要保持一致；

  

## 动态代理是什么？有哪些应用？

根据对象在**内存中加载的Class类**创建运行时类对象，从而为其他对象提供一种代理以控制对这个对象的访问。

应用：
Spring的AOP，加事务，加权限，加日志。

扩展：

**静态代理**是自己手写一个代理类，代理类中直接调用目标方法，以及添加额外功能。

而动态代理则不用我们手写，而是依赖于java反射机制。

## 怎么实现动态代理？

JDK动态代理、CGLIB动态代理；

**JDK动态代理（类实现接口）**：可以直接使用，不依赖第三方。

```java
public final class XXX extends Proxy implements XXX
```

- 实现InvocationHandler接口，重写invoke方法；
- Proxy.newProxyInstance（）获取到代理对象；

```java
package com.example.demo.test.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JDKProxy {

    public static void main(String[] args) {

        JDKProxy jdkProxy = new JDKProxy();
        People proxy = jdkProxy.proxy();
        proxy.hello(" 谢 谢 ");
    }

    public People proxy() {

        People people = new Person();
        return (People) Proxy.newProxyInstance(people.getClass().getClassLoader(),
                new Class[]{People.class}, new CustomInvocationHandler(people));
    }
}

class CustomInvocationHandler implements InvocationHandler {

    private Object people;
    public CustomInvocationHandler(Object people) {
        this.people = people;
    }
    /**
     * proxy : 把代理对象自己传递进来 
     * method：把代理对象当前调用的方法传递进来 
     * args:把方法参数传递进来
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("被代理了的参数" + args.length);
        return method.invoke(people, args);
    }
}

class Person implements People {

    public String hello(String a) {
        System.out.println("方法参数" + a);
        return a.trim();
    }
}

interface People {
    String hello(String a);
}
```

CGLIB动态代理：

继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。
根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。

- 实现MethodInterceptor接口，重写intercept方法；
- 设置代理类，Enhancer.setSuperclass(UserServiceImpl.class);
- 设置回调方法，Enhancer.setCallback(new CustomMethodInterceptor())；
- 创建代理类，Enhancer.create()

```java
package com.example.demo.test.proxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CglibProxy {

    public static void main(String[] args) {

        Enhancer enhancer = new Enhancer();
        //继承被代理类
        enhancer.setSuperclass(UserServiceImpl.class);
        // 设置回调方法
        enhancer.setCallback(new CustomMethodInterceptor());
        // 创建代理对象
        UserServiceImpl userServicer = (UserServiceImpl)enhancer.create();
        userServicer.addUser();
    }
}

class CustomMethodInterceptor implements MethodInterceptor{

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("事务开始。。。");
        Object result = proxy.invokeSuper(o, args);
        System.out.println("事务结束。。。");
        return result;
    }
}

/**
 * 业务类没有实现接口
 * 如果类是final的，则无法生成代理对象，报错
 * 如果方法是final的，代理无效
 */
class UserServiceImpl {
    
    public void addUser() {
        System.out.println("增加一个用户。。。");
    }
}
```

jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib。



# 五、对象拷贝

## 为什么要使用克隆？

clone方法是在复制一个对象，赋值的对象是单独独立的，有独自的内存空间。

clone方法是java中顶层父类Object中的一个方法，此方法在java中为实现，是一个native方法，也就是本地方法（可以调用底层操作系统的方法），在调用本地方法创建对象，比直接new创建对象效率高。



## 如何实现对象克隆？

两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。
在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。
有两种方式：

1. 实现**Cloneable接口**并重写Object类中的clone()方法；

   - 实现Cloneable接口；
   - 重载Object类中的clone()方法，重载时需定义为public；
   - 在重载方法中，调用super.clone()；

   ```java
   public Object clone() {
           Student o = null;
           try {
               o = (Student) super.clone();
           } catch (CloneNotSupportedException e) {
               System.out.println(e.toString());
           }
           o.p = (Professor) p.clone();//要克隆的对象中引用类型
           return o;
       }
   ```

   

2. 实现**Serializable接口**，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆；

   - 实现Serializable接口；
   - ByteArrayOutputStream和ObjectOutputStream.writeObject方法序列化对象；
   - ByteArrayInputStream和ObjectInputStream.readObject()反序列化对象得到克隆对象；

```java
public Object deepClone() throws IOException, OptionalDataException,
            ClassNotFoundException {
        // 将对象写到流里
        ByteArrayOutputStream bo = new ByteArrayOutputStream();
        ObjectOutputStream oo = new ObjectOutputStream(bo);
        oo.writeObject(this);//this指要克隆的对象
        // 从流里读出来
        ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
        ObjectInputStream oi = new ObjectInputStream(bi);
        return (oi.readObject());
    }
```



# 六、Java Web

## jsp 和 servlet 有什么区别？

jsp和servlet的区别和联系：

1.jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)

2.jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.

3.Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.

Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。
联系：  JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑



## jsp 有哪些内置对象？作用分别是什么？

**request：**表示HttpServletRequest对象，用户端请求。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。

**response：**表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等），网页传回用户端的回应

**out：**对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。

**pageContext：**表示一个javax.servlet.jsp.PageContext对象。该对象提供了对JSP页面内所有的对象及名字空间（就是四大作用域空间，如page空间、request空间、session空间、application空间）的访问，也就是说他可以访问到当前请求对应session中保存的信息，也可以取当前应用所在的application的某一属性值，它相当于页面中所有功能的集大成者，包装了通用的servlet相关功能的方法。

**session：**表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息

**applicaton：**表示一个javax.servle.ServletContext对象。类似于系统的全局变量，用于实现Web应用中的资源共享。

**config：**表示一个javax.servlet.ServletConfig对象。用于存放JSP编译后的初始数据。

**page：**表示从该页面产生的一个servlet实例，JSP网页本身

**exception：**针对错误网页，未捕捉的例外。表示JSP页面运行时产生的异常和错误信息，该对象只有在错误页面（page指令中设定isErrorPage为true的页面）中才能够使用。

注意到:

四大作用域：pageContext request session application 可以通过 jstl从四大作用域中取值.

request session application 用于jsp递值 



## 说一下 jsp 的 4 种作用域？

page、request、session、application

**Page**：用户请求的当前页面；

**Request**：用户请求访问的当前组件，以及和当前web组件共享同一用户请求的web组件。如：被请求的jsp页面和该页面用<include>指令包含的页面以及<forward>标记包含的其它jsp页面； 

**Session**：同一个http会话中的web组件共享它；
**Application**：整个web应用的所用web组件共享它。



## session 和 cookie 有什么区别？

## 说一下 session 的工作原理？

## 如果客户端禁止 cookie 能实现 session 还能用吗？

## spring mvc 和 struts 的区别是什么？

## 如何避免 sql 注入？

## 什么是 XSS 攻击，如何避免？

## 什么是 CSRF 攻击，如何避免？

# 七、异常

![img](https://img-blog.csdn.net/20170622192453860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI4NjAzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

所有抛出的异常都是从Throwable派生而来。类Throwable有两个直接子类：Error和Exception；

Error类对象由虚拟机生成并抛出，比如内存泄漏，通常Java程序不对这类异常进行处理；

运行时异常和非运行时异常：

继承自RuntimeException是**运行时异常，unchecked  exceptions**，不必处理，比如空指针异常，非法参数异常，类找不到异常，NullPointerException(空指针异常)、 
IndexOutOfBoundsException(下标越界异常) 、
ClassCastException(类转换异常) 、
ArrayStoreException(数据存储异常，操作数组时类型不一致) 、
IO操作的BufferOverflowException异常 、

其他为**非运行时异常，checked   exceptions**，需要处理，如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

## throw 和 throws 的区别？

throw用于方法体内部，用来抛出一个Throwable类型的异常。

​	如果抛出了检查性异常，则还应该在头部声明方法可能抛出的异常类型，该方法调用者也必须检查处理抛出的异常。

​	如果抛出的是非检查型异常或者Error，该方法的调用者可以选择处理该异常。

throws用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。



## final、finally、finalize 有什么区别？

**final：**

​	修饰成员：变量一旦被初始化便不可更改，对于基本类型来时是值不可变，对于对象变量来说是引用不可变，初始化可以在两个地方，一个是定义处，一个是构造器内；

​	修饰方法：方法无需再进行扩展，继承此类的类可以继承这个方法，但是不能重写这个方法。

​		允许编译器将所有对此方法的调用转为行内调用，直接将方法主体插入到调用处，可以省略保存断点，压栈		等步骤，使程序效率有所提高。但是当方法主体庞大时，反而会影响效率，慎用。

​	修饰类：类不可被继承，类不需要进行修改和扩展时使用。类上加final，成员变量可以定义final或者不定义，

​	但是方法默认为final；

**finally：**

​	finally结构使代码总会执行，不管有无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。finally只有一种情况不会执行。当执行到System.exit(0);finally不会执行。

​	finally代码块中有异常的时候，try和catch块中的异常无法抛出，但是try和catch中的代码可以正常执行；

**finalize：**

​	方法是在Object中定义的，垃圾回收器在确定对象没有被引用时，也就是清理对象之前对这个方法进行调用，Object中定义的方法体为空，子类继承这个方法可以实现垃圾回收器在将对象从内存清除出去之前整理系统资源或者其他的清理工作。



## try-catch-finally 中哪个部分可以省略？

catch和finally语句不能同时省略！！！ 



## try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

会；

**特殊实例：**

finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。finally还可以改变引用类型的值；

```Java
public static void main(String[] args) {
        int k = f_test();
        System.out.println(k);
    }

    public static int f_test(){
        int a = 0;
        try{
            a = 1;
            return a;
        }
        finally{
            System.out.println("It is in final chunk.");
            a = 2;
            return a;
        }
    }
/*输出： 
It is in final chunk.
2*/
```



## 常见的异常类有哪些？

**运行时异常：**

ArithmeticException——由于除数为0引起的异常；

ArrayStoreException——由于数组存储空间不够引起的异常；

ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常；

IllegalMonitorStateException——监控器状态出错引起的异常；

NegativeArraySizeException—一数组长度是负数，则产生异常；

NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； OutofMemoryException——用new语句创建对象时，如系统无法为其分配内存空 间则产生异常；

SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常；

IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常；

IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常；

ClassNotFoundException——未找到指定名字的类或接口引起异常；

CloneNotSupportedException——一程序中的一个对象引用Object类的clone方法，但 此对象并没有连接Cloneable接口，从而引起异常；

InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述；

NoSuchMethodException一所调用的方法未找到，引起异常；

Illega1AccessExcePtion—一试图访问一个非public方法；

StringIndexOutOfBoundsException——访问字符串序号越界，引起异常；

ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常；

NumberFormatException——字符的UTF代码数据格式有错引起异常；

IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常；

FileNotFoundException——未找到指定文件引起异常；

EOFException——未完成输入操作即遇文件结束引起异常。

**非运行时异常：**

IOException；

SqlException；



# 八、网络

## http 响应码 301 和 302 代表的是什么？有什么区别？

## forward 和 redirect 的区别？

## 简述 tcp 和 udp的区别？

## tcp 为什么要三次握手，两次不行吗？为什么？

## 说一下 tcp 粘包是怎么产生的？

## OSI 的七层模型都有哪些？

![img](https://img-blog.csdn.net/20180930214143743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbjEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**物理层**：设备之间比特流的传输，物理接口，电气特性等等。常见的设备有网线，网卡等等。数据单位是比特

**数据链路层**：成帧，用Mac地址访问媒介，错误检测与修正。数据单位是帧

**网络层**：提供逻辑地址（IP地址）、选路（选择传输路线）。数据单位是报文

**传输层**：确定传输的可靠性以及每种协议的端口号，传输前的错误检测，流控。数据单位是TPDU

**会话层**：对应用会话的管理，同步。确定网络数据是否要经过远程会话 。数据单位是SPDU

**表示层**：数据的表现形式，特定功能的实现，比如加密压缩等。数据单位是PPDU

**应用层**：用户接口，无限接近用户。数据单位是APDU

其中应用层、表示层和会话层是为用户提供服务的。传输层、网络层、数据链路层和物理层是为传输数据提供服务的。



## get 和 post 请求有哪些区别？

1. GET**参数**通过URL传递，POST放在Request body中。
2. GET请求在URL中传送的**参数是有长度**限制的，而POST没有。
3. GET比POST更**不安全**，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 
4. GET在浏览器回退时是无害的，而POST会再次提交请求。
5. GET产生的URL地址可以被Bookmark，而POST不可以。
6. GET请求会被**浏览器主动cache**，而POST不会，除非手动设置。
7. GET请求只能进行url编码，而POST支持多种编码方式。
8. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
9. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。



## 如何实现跨域？

## 说一下 JSONP 实现原理？

# 九、设计模式

## 说一下你熟悉的设计模式？

**代理模式**：

​	概念：给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

​	作用：

​		**中介隔离作用：**在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户		类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。

​		**开闭原则，增加功能：**代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来**扩展委托类的功能**，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。

​	代理模式：

​		静态代理、动态代理（JDK代理，Cglib代理）







## 简单工厂和抽象工厂有什么区别？



# 十、Spring/Spring MVC

## 为什么要使用 spring？

它提供了一个Web应用程序的基本框架；

1. Spring提供一个容器/工厂，**统一管理模块的定义，根据需要创建**。

2. 把模块的配置参数统一管理，模块不需要自行读取配置。

3. Spring提供依赖注入，把**依赖的模块自动**推送进来，不需要模块自己拉取。

4. 此外，Spring提供了对**很多其他第三方框架**的集成功能，减少了样板代码（boilerplate）。

   

## 解释一下什么是 aop？





## 解释一下什么是 ioc？



## spring 有哪些主要模块？



## **Spring中bean的生命周期**

在Web应用程序启动过程中，Spring容器中的每个bean也有各自的初始化顺序。一个bean，从bean definition被加载到初始化完成，按照以下顺序执行：

1. BeanFactory加载完bean definition和class，实例化除了bean对象。

2. 检查有没有实现BeanNameAware，有则调用setBeanName（得到bean id）

3. 检查有没有实现BeanClassLoaderAware，有则调用setBeanClassLoader。

4. 检查有没有实现EnvironmentAware，有则调用setEnvironment。

5. 检查有没有实现EmbeddedValueResolverAware，有则调用setEmbeddedValueResolver。

6. 检查有没有实现ResourceLoaderAware，有则调用setResourceLoader。

7. 检查有没有实现ApplicationEventPublisherAware，有则调用setApplicationEventPublisher。

8. 检查有没有实现MessageSourceAware，有则调用setMessageSource。

9. 检查有没有实现ApplicationContextAware，有则调用setApplicationContext。

10. 检查有没有实现ServletContextAware，有则调用setServletContext。

11. 调用BeanPostProcessors中的所有postProcessBeforeInitialization，对bean进行一些更进一步的配置。

12. 调用InitializingBean接口中的afterPropertiesSet执行bean自身提供的初始化代码。

13. 调用通过其他方式指定的init-method方法，执行bean自身的初始化。

14. 调用BeanPostProcessors中的所有postProcessAfterInitialization方法。



## spring 常用的注入方式有哪些？

**三种属性注入方式**：

**set方法注入**；

**构造方法注入**



## @Autowired和@Resource区别？

@Autowired自动装配（注解是属业spring）：

- **默认根据类型**注入，可以用于构造器、接口、方法注入；
- 默认required=true，如果允许出现0个Bean候选者需要设置属性“required=false”；

@Autowired是根据类型进行自动装配的。如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出BeanCreationException异常;如果Spring上下文中不存在UserDao类型的bean，也会抛出BeanCreationException异常。我们可以使用@Qualifier配合@Autowired来解决这些问题。如下：

```java
@Autowired   
@Qualifier("userServiceImpl")   
public IUserService userService;   
```

@Resource（注解属于J2EE）：

可以标注在字段或属性的setter方法上，但它**默认按名称装配**。

- 名称可以通过@Resource的name属性指定；
- 当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象；
- 当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象；
- 如果没有找到该名称，则会按照类型去寻找；



## spring 中的 bean 是线程安全的吗？

Spring Bean是非线程安全的。

**单实例 singleton（缺省）**：

在整个Spring IoC容器里，只有一个bean实例，所有线程共享该实例；

 **原型实例prototype：**

每次请求都会创建并返回一个新的实例，所有线程都有单独的实例使用，这种方式是比较安全的，但会消耗大量内存和计算资源。



## spring 支持几种 bean 的作用域？

当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下**5种**作用域：

- **singleton**：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例
- **prototype**：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例
- **request**：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效
- **session**：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效
- **globalsession**：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效。



## spring 自动装配 bean 有哪些方式？



## spring 事务实现方式有哪些？



## 说一下 spring 的事务隔离？



## 说一下 spring mvc 运行流程？



## spring mvc 有哪些组件？



## @RequestMapping 的作用是什么？



## @Autowired 的作用是什么？



# 十一、Spring Boot/Spring Cloud

## 什么是 spring boot？

SpringBoot是一个框架，一种全新的编程规范,简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。



## 为什么要用 spring boot？

让文件配置变的相当简单;

让应用部署变的简单（SpringBoot内置服务器，并装备启动类代码），可以快速开启一个Web容器进行开发。

- 独立运行
- 简化配置
- 自动配置
- 无代码生成和XML配置
- 应用监控
- 上手容易

```
Spring Boot会根据项目中依赖的jar包自动配置项目的配置项，* 比如：添加了spring-boot-starter-web的依赖，项目中也就会引入SpringMVC的依赖，并且Spring Boot会自动配置tomcat 和SpringMVC。
```

## spring boot 核心配置文件是什么？

Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。

application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。

bootstrap 配置文件有以下几个应用场景。

- 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
- 一些固定的不能被覆盖的属性；
- 一些加密/解密的场景;



## spring boot 配置文件有哪几种类型？它们有什么区别？

Spring Boot会自动加载classpath目前下的这两个文件，文件格式为 properties 或 yml 格式；



## spring boot 有哪些方式可以实现热部署？

第一种：依赖**spring-boot-devtools**实现，将以下代码放到dependencies中：

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

第二种：在 spring-boot-maven-plugin 插件配置中添加 **springloaded** 依赖。

```java
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <dependencies>
                <dependency>
                    <groupId>org.springframework</groupId>
                    <artifactId>springloaded</artifactId>
                    <version>1.2.5.RELEASE</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```

**必须通过mvn spring-boot:run 命令启动应用， 修改代码或页面才会更新。**



## jpa 和 hibernate 有什么区别？

## 什么是 spring cloud？

Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：

- eureka (提供服务注册与发现功能)
- ribbon（提供负载均衡功能）
- Feign（整合了ribbon和Hystrix，具有负载均衡和熔断限流等功能）
- Hystrix （提供了熔断限流，合并请求等功能）
- Zuul （提供了智能路由的功能）
- Hystrix Dashboard （提供了服务监控的功能，提供了数据监控和友好的图形化界面）
- Hystrix Turbine （Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。也是监控系统的功能）
- spring cloud config （提供了统一配置的功能）
- Spring Cloud Bus （提供了配置实时更新的功能）



## spring cloud 断路器的作用是什么？

## spring cloud 的核心组件有哪些？

# 十二、Hibernate

## 为什么要使用 hibernate？

## 什么是 ORM 框架？

## hibernate 中如何在控制台查看打印的 sql 语句？

## hibernate 有几种查询方式？

## hibernate 实体类可以被定义为 final 吗？

## 在 hibernate 中使用 Integer 和 int 做映射有什么区别？

## hibernate 是如何工作的？

## get()和 load()的区别？

## 说一下 hibernate 的缓存机制？

## hibernate 对象有哪些状态？

## 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

## hibernate 实体类必须要有无参构造函数吗？为什么？

# 十三、Mybatis

## mybatis 中 #{}和 ${}的区别是什么？

## mybatis 有几种分页方式？

## RowBounds 是一次性查询全部结果吗？为什么？

## mybatis 逻辑分页和物理分页的区别是什么？

## mybatis 是否支持延迟加载？延迟加载的原理是什么？

## 说一下 mybatis 的一级缓存和二级缓存？

## mybatis 和 hibernate 的区别有哪些？

## mybatis 有哪些执行器（Executor）？

## mybatis 分页插件的实现原理是什么？

## mybatis 如何编写一个自定义插件？

# 十六、Zookeeper

## zookeeper 是什么？

## zookeeper 都有哪些功能？

## zookeeper 有几种部署模式？

## zookeeper 怎么保证主从节点的状态同步？

## 集群中为什么要有主节点？

## 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

## 说一下 zookeeper 的通知机制？

# 十七、MySql

## 数据库的三范式是什么？

## 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

## 如何获取当前数据库版本？

## 说一下 ACID 是什么？

## char 和 varchar 的区别是什么？

## float 和 double 的区别是什么？

## mysql 的内连接、左连接、右连接有什么区别？

## mysql 索引是怎么实现的？

## 怎么验证 mysql 的索引是否满足需求？

## 说一下数据库的事务隔离？

## 说一下 mysql 常用的引擎？

## 说一下 mysql 的行锁和表锁？

## 说一下乐观锁和悲观锁？

## mysql 问题排查都有哪些手段？

## 如何做 mysql 的性能优化？

# 十八、Redis

## redis 是什么？都有哪些使用场景？

## redis 有哪些功能？

## redis 和 memecache 有什么区别？

## redis 为什么是单线程的？

## 什么是缓存穿透？怎么解决？

## redis 支持的数据类型有哪些？

## redis 支持的 java 客户端都有哪些？

## jedis 和 redisson 有哪些区别？

## 怎么保证缓存和数据库数据的一致性？

## redis 持久化有几种方式？

## redis 怎么实现分布式锁？

## redis 分布式锁有什么缺陷？

## redis 如何做内存优化？

## redis 淘汰策略有哪些？

## redis 常见的性能问题有哪些？该如何解决？

# 十九、JVM

## 说一下 jvm 的主要组成部分？及其作用？

## 说一下 jvm 运行时数据区？

## 说一下堆栈的区别？

## 队列和栈是什么？有什么区别？

## 什么是双亲委派模型？

## 说一下类加载的执行过程？

## 怎么判断对象是否可以被回收？

## java 中都有哪些引用类型？

## 说一下 jvm 有哪些垃圾回收算法？

## 说一下 jvm 有哪些垃圾回收器？

## 详细介绍一下 CMS 垃圾回收器？

## 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？

## 简述分代垃圾回收器是怎么工作的？

## 说一下 jvm 调优的工具？

## 常用的 jvm 调优的参数都有哪些？