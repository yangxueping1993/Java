# 一、Java 基础

## Java语言特性

**抽象**。抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：过程抽象；数据抽象。

 **继承**。继承是一种连接类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类的继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且派生类可以修改或者增加新的方法使之更适合特殊的需要。

 **封装**。*封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护*。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

 **多态**。多态是指允许不同类的对象对同一消息做出响应。多态包括参数化多态和包含多态。多态性语言具有灵活、抽象、行为共享、代码共享等优势，很好地解决了应用程序函数同名问题。Java中实现多态主要是方法的重载和方法的覆盖。





## JDK 和 JRE 有什么区别？

**JRE（Java Runtime Environment）：**

​	包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的，还有所有的Java类库的class文件，都在lib目录下，并且都打包成了jar。

**JDK(Java Development Kit)：**

​	是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。

JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。

简单来说，JRE可以支撑Java程序的运行，包括JVM虚拟机（java.exe等）和基本的类库（rt.jar等），JDK可以支持Java程序的开发，包括编译器（javac.exe）、开发工具（javadoc.exe、jar.exe、keytool.exe、jconsole.exe）和更多的类库（如tools.jar）等。

 

## == 和 equals 的区别是什么？

**Java数据类型分为：**

　　　　　　　　　基本数据类型

　　　　　　　　　复合数据类型（包装类是基本数据类型的引用类型也属于复合数据类型）

**基本数据类型：**

　　　　　　byte，short，int，long，float，double，char，boolean 

**复合数据类型：**

　　　　　　　包装类：Byte ,Short,Integer,Long,Float,Double,Character,Boolean

　　　　　　　对象：var obj ={"name":"xiaoming"}

　　　　　　　数组: var objarr = ["1","2","3"]

　　　　　　　函数:function f(){}

1）基本数据类型之间比较用 == 且比较值，而复合数据类型 == 比较的时候两对象的地址值是否一致，所以除非是同一个new出来的对象，结果为true，否则为false。

2）对于equals() 由于java中所有类都继承与Object基类，在Object类中定义了一个equals()，该方法初始化是比较对象的内存地址。



但在一些类中重写了这个方法，如包装类String,Date等，equals()比较的是两个变量的值。

String

创建String对象的两种方式比较他们的==和equals会有不同的效果

```Java
String s1=”sss”;
String s2=new String(“sss”);
System.out.println(s1==s2);//false
System.out.println(s1.equals(s2));//true
```



研究这个结果就需要了解一下String对象的创建机制。

String s1=”sss”;这种创建方式在内存中的过程是在***方法区的常量池中创建一个”sss”字面值*** ，然后之后由这种创建方式的变量都由栈中指向这个地址，所以只要值一样，变量之间==为true;

而String s2=new String(“sss”);这种创建方式的过程具体是在***堆中创建一个新的对象***，所以在和值一样的变量比较==时为false，但是只要值一样的话.equals()还是为true的。

String中还有个特殊的地方就是使用**+号拼接得到的结果**：

如果值和某变量值一致，不代表两变量地址一致，

​	如果拼接的是一个字面值，则指向同一个值的常量池地址，两变量地址一致。
​	但如果拼接的是一个变量相当于新建了一个对象，地址指向堆，所以即使值一致，地址也不一样。	

```Java
String a = "ab";
String b = "a" + "b";
String c = "a";
String d = c + "b";
System.out.println(a == b);//true
System.out.println(a == d);//false
```



String中有个**intern()**方法。

 这个方法的作用是**在常量池中检查是否有和该字符串相同的值，如果有，则返回常量值，若没有就创建该常量值，并返回。所以通过intern()得到的值会和指向同一个常量池值的变量地址一致且值一致**

```java
String a = "ab";
String c = "a";
String d = c + "b"
String intern = d.intern();
System.out.println(intern == d);//false
System.out.println(intern == a);//true
```

针对String简单的总结一下：

①只要不新建对象，值相同地址一般相等

②String身为一个不可变值，对字符串的操作会新建一个对象。

③拼接时关注字符串是否新建对象





·包装类

当包装类和基本类型**进行”==”比较时，包装类会自动拆箱为基本数据类型再进行比较**。而字面值的地址都指向常量池，值相同地址相同。

两个相同包装类型的对象**进行equals()比较时，equals()会先比较类型，如果类型相同再比较值，二者同时成立为true**，**包装类调用equals()，但是参数是基本类型，这时候会先进行自动装箱，基本类型转换为其包装类，先判断类型，再判断值，二者都成立时结果为true**

```Java
 int a = 1;
 Integer b = new Integer(1);
 System.out.println(a == b);//true
 System.out.println(b.equals(a));//true
```

两个基本类型没有equals()比较方法；



以Integer为例讨论一下直接赋值的情况下两变量的==结果和equals()值：

因为Integer对象在编译期会自动拆箱（该特性在jdk1.5之后）。

```Java
Integer i1 = 123;
Integer i2 = 123;
System.out.println(i1 == i2);//true
Integer i3 = 200;
Integer i4 = 200;
System.out.println(i3 == i4);//false
Integer i5 = new Integer(123);
System.out.println(i1 == i5);//false
Integer i6 = Integer.valueOf(123);
System.out.println(i1 == i6);//true
```

这个结果就很神奇，和上一个例子明明一样为什么结果不一样。这是因为Integer自动拆箱的过程：Integer i1=200在编译期会调用一个叫valueOf()的静态方法

```Java
  public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

由此可知，cache是一个数组，规定了整型在[-127,128]这个范围。超过这个范围的值就会在堆内存中创建一个新的对象，两对象地址不同。

运行时常量池会放入：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）

针对Integer简单总结一下：

①无论如何Integer变量不会和新创建的对象相等。

②Integer在==比较时会在编译时期自动拆箱。



## 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

```JAVA
 Person person = new Person();
        System.out.println(person);//com.example.demo.test.equals_hascode.Person@28ba21f3
        System.out.println(person.getClass().getName()+"@"+Integer.toHexString(person.hashCode()));//com.example.demo.test.equals_hascode.Person@28ba21f3
```

hashCode（)内存中编号，方便寻址；

- 哈希函数、散列函数；

- 单向函数，反向运算无法完成；

- 任意长度输入，固定长度输出；

- 输入不变，输出不变；

- 常见

  - MD5加密+salt

    

关于hashCode和equal是方法是有一些 常规协定 ：

1、两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。
2、两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。
3、重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。



## java 中的 Math.round(-1.5) 等于多少？

Math.round(1.5)的返回值是2，Math.round(-1.5)的返回值是-1。四舍五入的原理是在参数上加0.5然后做向下取整。

## java 中操作字符串都有哪些类？它们之间有什么区别？

String和StringBuffer、StringBuilder；

- String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。 

- StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。

- StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。
  不频繁的字符串操作使用 String。反之，StringBuffer 和 StringBuilder 都优于String；

  

## 如何将字符串反转？

方法4  调用StringBuffer中的reverse方法

```java
public static String reverse4(String s) {
  return new StringBuffer(s).reverse().toString();
 }
```

方法5 把字符串转换成字符数组首位对调位置

```Java
public static String reverse5(String orig) {
  char[] s = orig.toCharArray();
  int n = s.length - 1;
  int halfLength = n / 2;
  for (int i = 0; i <= halfLength; i++) {
   char temp = s[i];
   s[i] = s[n - i];
   s[n - i] = temp;
  }
  return new String(s);
 }
```

//方法1 递归方法

```Java
public static String reverse1(String s) {
  int length = s.length();
  if (length <= 1){
     return s;
    }
  String left = s.substring(0, length / 2);
  String right = s.substring(length / 2, length);
  return reverse1(right) + reverse1(left);
 }
```



## String 类的常用方法都有那些？

java.lang.String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。

**String类构造方法**

1. public String(char[] value)
   用字符数组value创建一个String对象。
2. public String(char chars[], int startIndex, int numChars)
   用字符数组chars的startIndex开始的numChars个字符创建一个String对象。
3. public String(byte[] values)
   用比特数组values创建一个String对象。

**String类常用方法**

1. 求字符串长度；

2. 求字符串某一位置字符；

   **public char charAt(int index)**//返回字符串中指定位置的字符；

   注意字符串中第一个字符索引是0，最后一个是length()-1。

   ```java
   String str = new String("asdfzxc");
   char ch = str.charAt(4);//ch = z
   ```

3. 提取子串；

   ```java
   1 String str1 = new String("asdfzxc");
   2 String str2 = str1.substring(2);//str2 = "dfzxc"
   3 String str3 = str1.substring(2,5);//str3 = "dfz"
   ```

4. 字符串比较
   对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。

   ```java
   String str1 = new String("abc");
   String str2 = new String("ABC");
   int a = str1.compareTo(str2);//a>0
   int b = str1.compareToIgnoreCase(str2);//b=0
   boolean c = str1.equals(str2);//c=false
   boolean d = str1.equalsIgnoreCase(str2);//d=true
   ```

   **regionMatches(boolean b, int firstStart, String other, int otherStart, int length)**
   从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。

   ```java
   String str1 = new String("abc");
   String str2 = new String("ABC");
   System.out.println(str1.regionMatches(true, 0, str2, 0, 3));//true
   System.out.println(str1.regionMatches(false, 0, str2, 0, 3));//false
   System.out.println(str1.regionMatches(true, 0, str2, 1, 3));//false
   System.out.println(str1.regionMatches(0, str2.toLowerCase(), 0, 3));//true
   ```

5. 字符串连接

   ```JAVA
   1 String str = "aa".concat("bb").concat("cc");
   2 相当于String str = "aa"+"bb"+"cc";
   ```

6. 字符串中单个字符查找（各个字符位置索引固定，规则查找匹配到的字符）

   ```JAVA
   String str = "I am a good student";
   int a = str.indexOf('a');//a = 2
   int b = str.indexOf("good");//b = 7
   int c = str.indexOf("w",2);//c = -1
   int d = str.lastIndexOf("a");//d = 5 从后向前查找遇到第一个a的位置
   int e = str.lastIndexOf("a",3);//e = 2 指定位置从后向前，遇到第一个a的位置
   ```

7. 字符串中字符的大小写转换

   ```JAVA
   1 String str = new String("asDF");
   2 String str1 = str.toLowerCase();//str1 = "asdf"
   3 String str2 = str.toUpperCase();//str2 = "ASDF"
   ```

8. 字符串中字符的替换

   ```JAVA
   1 String str = "asdzxcasd";
   2 String str1 = str.replace('a','g');//str1 = "gsdzxcgsd"
   3 String str2 = str.replace("asd","fgh");//str2 = "fghzxcfgh"
   4 String str3 = str.replaceFirst("asd","fgh");//str3 = "fghzxcasd"
   5 String str4 = str.replaceAll("asd","fgh");//str4 = "fghzxcfgh"
   ```

9. 截取空格（只能截取首尾空格）

   ```java
   1 String str = " a sd ";
   2 String str1 = str.trim();
   3 int a = str.length();//a = 6
   4 int b = str1.length();//b = 4
   ```

10. 判断首位字符

    ```java
    1 String str = "asdfgh";
    2 boolean a = str.statWith("as");//a = true
    3 boolean b = str.endWith("gh");//b = true
    ```

11. 是否包含子串

    ```java
    1 String str = "student";
    2 str.contains("stu");//true
    3 str.contains("ok");//false
    ```

12. 分解成数组

    ```
    1 String str = "asd!qwe|zxc#";
    2 String[] str1 = str.split("!|#");//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc"
    ```

    

**字符串与基本类型的转换**

1、字符串转换为基本类型
java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：
1)public static byte parseByte(String s)
2)public static short parseShort(String s)
3)public static short parseInt(String s)
4)public static long parseLong(String s)
5)public static float parseFloat(String s)
6)public static double parseDouble(String s)
例如：

```java
1 int n = Integer.parseInt("12");
2 float f = Float.parseFloat("12.34");
3 double d = Double.parseDouble("1.124");
```

2、基本类型转换为字符串类型
String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。
1)static String valueOf(char data[])
2)static String valueOf(char data[], int offset, int count)
3)static String valueOf(boolean b)
4)static String valueOf(char c)
5)static String valueOf(int i)
6)static String valueOf(long l)
7)static String valueOf(float f)
8)static String valueOf(double d)
例如：

```java
1 String s1 = String.valueOf(12);
2 String s1 = String.valueOf(12.34);
```

3、进制转换
使用Long类中的方法得到整数之间的各种进制转换的方法：
Long.toBinaryString(long l)
Long.toOctalString(long l)
Long.toHexString(long l)
Long.toString(long l, int p)//p作为任意进制



## 抽象类必须要有抽象方法吗？

1. 抽象类必须有关键字abstract来修饰。

2. 抽象类可以不含有抽象方法

3. 如果一个类包含抽象方法，则该类必须是抽象类

   

## 普通类和抽象类有哪些区别？

1. 普通类中不可含有抽象方法，可以被实例化；

2. 抽象类，则抽象类中所有的方法自动被认为是抽象方法，没有实现过程，不可被实例化；抽象类的子类，除非也是抽象类，否则必须实现该抽象类声明的方法

   

## 抽象类能使用 final 修饰吗？

不能； 



## 接口和抽象类有什么区别？

抽象类是先天性获得技能，抽象类是后天习得技能；

**抽象类：**

抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。

**接口：**

接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。

![1573272588789](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573272588789.png)

## java 中 IO 流分为几种？

按照流的流向分，可以分为输入流和输出流；

按照操作单元划分，可以划分为字节流和字符流；

按照流的角色划分，为节点流和处理流。

•InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。

•OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

![1573279044193](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573279044193.png)

表中粗体字所标出的类代表节点流；







## BIO、NIO、AIO 有什么区别？

## Files的常用方法都有哪些？

# 二、容器

## java 容器都有哪些？

![1572501952136](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572501952136.png)





## Collection 和 Collections 有什么区别？

Collections方法：

![1572533086719](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572533086719.png)

## List、Set、Map 之间的区别是什么？

List、Set是实现了Collection接口的子接口；而Map是另一个集合接口；

三者之间的区别如下：

1) 元素重复性：

① **List允许有重复的元素**。任何数量的重复元素都可以在不影响现有重复元素的值及其索引的情况下插入到List集合中；

② **Set集合不允许元素重复。**Set以及所有实现了Set接口的类都不允许重复值的插入，若多次插入同一个元素时，在该集合中只显示一个；

③ Map以键值对的形式对元素进行存储。**Map不允许有重复键，但允许有不同键对应的重复的值；**

2) 元素的有序性：

① List及其所有实现类保持了每个元素的插入顺序；

② Set中的元素都是无序的；但是某些Set的实现类以某种殊形式对其中的元素进行排序，如：**LinkedHashSet**按照元素的插入顺序进行排序；

③ Map跟Set一样对元素进行无序存储，但其某些实现类对元素进行了排序。如：TreeMap根据键对其中的元素进行升序排序；

3) 元素是否为空值：

① List允许任意数量的空值；

② Set最多允许一个空值的出现；[ 当向Set集合中添加多个null值时，在该Set集合中只会显示一个null元素]

③  Map只允许出现一个空键，但允许出现任意数量的空值；

总结： List中的元素，有序、可重复、可为空；

Set中的元素，无序、不重复、只有一个空元素；

Map中的元素，无序、键不重，值可重、可一个空键、多可空值；



HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的；

LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。

TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；



## HashMap 和 Hashtable 有什么区别？

•	HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：

•	HashMap允许键和值是null，而**Hashtable不允许键或者值是null**。

•	**Hashtable是同步的**，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。

•	HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。

o	一般认为Hashtable是一个遗留的类。





## 如何决定使用 HashMap 还是 TreeMap？

TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。



## 说一下 HashMap 的实现原理？

HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。	

![img](http://dl.iteye.com/upload/picture/pic/63364/042032ea-6f15-3428-bfb4-b3b1460769a7.jpg)

HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。

```java
transient Entry[] table;  
  
static class Entry<K,V> implements Map.Entry<K,V> {  
    final K key;  
    V value;  
    Entry<K,V> next;  
    final int hash;  
    ……  
}
//可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。
```









![1572526737655](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572526737655.png)

LinkedHashMap：

底层由哈希表和链表实现；哈希表保证键的唯一性，链表保证有序，指插入和读取有序；

TreeMap：

基于红黑树Map接口的实现；

插入元素默认自然排序；



****

## 说一下 HashSet 的实现原理？

   HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。

   对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成。







## ArrayList 和 LinkedList 的区别是什么？

ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问;

LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。

LinkedList的插入，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

只要ArrayList的当前容足够大，add()操作向数组的尾部的效率非常高的，当向数组指定位置添加数据时，会进行大量的数组移动复制操作。而数组复制时，最终将调用System.arraycopy()方法，因此add()操作的效率还是相当高的。尽管这样当向指定位置添加数据时也还是比Linkedlist慢，后者添加数据只需要改变指针指向即可。


![img](https://img-blog.csdn.net/20180724111654310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ2ODUyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





## 如何实现数组和 List 之间的转换？

**数组转List**：

```java
		String[] str=new String[] {"hello","world"};
		//方式一：使用for循环把数组元素加进list
		List<String> list=new ArrayList<String>();
		for (String string : str) {
			list.add(string);
		}
		System.out.println(list);
		
		//方式二：
		List<String> list2=new ArrayList<String>(Arrays.asList(str));
		System.out.println(list2);
		
		//方式三：
		//asList()返回的列表的大小是固定的。
		//事实上，返回的列表不是java.util.ArrayList类，而是定义在java.util.Arrays中一个私有静态类java.util.Arrays.ArrayList
		//这种情况下，如果添加或删除列表中的元素，程序会抛出异常UnsupportedOperationException。
		//java.util.Arrays.ArrayList extends AbstractList<E>具有 set()，get()，contains()等方法，但是不具有添加add()或删除remove()方法,所以调用add()方法会报错。
		List<String> list3 = Arrays.asList(str);
		
		//方式四：使用Collections.addAll()
		List<String> list4=new ArrayList<String>(str.length);
		Collections.addAll(list4, str);
		System.out.println(list4);
		
		//方式五：使用Stream中的Collector收集器
		//转换后的List 属于 java.util.ArrayList 能进行正常的增删查操作
		List<String> list5=Stream.of(str).collect(Collectors.toList());
		System.out.println(list5);
```

**List转数组：**

```java
		List<String> list=new ArrayList<String>();
		list.add("hello");
		list.add("world");
		
		//方式一：使用for循环
		String[] str1=new String[list.size()];
		for(int i=0;i<list.size();i++) {
			str1[i]=list.get(i);
		}
		
		//方式二：使用toArray()方法
		//list.toArray(T[]  a); 将list转化为你所需要类型的数组
		String[] str2=list.toArray(new String[list.size()]);
 		if (objects[0] instanceof String){
            String a = (String)objects[0];
        }
		//错误方式：易错   list.toArray()返回的是Object[]数组，怎么可以转型为String
		//ArrayList<String> list3=new ArrayList<String>();
		//String strings[]=(String [])list.toArray();
```







## ArrayList 和 Vector 的区别是什么？

（1）同步性：

 Vector是线程安全的，也就是说是它的方法之间是线程同步的；
ArrayList是线程序不安全的，它的方法之间是线程不同步的；
如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程。

（2）数据增长：

 Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。                          

ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提              

供设置增长空间的方法。



## Array 和 ArrayList 有何区别？

**ArrayList想象成一种“会自动扩增容量的Array”**

Array类型的变量在声明的同时必须进行实例化(至少得初始化数组的大小)，而ArrayList可以只是先声明。

Array只能存储同构的对象，而ArrayList可以存储异构的对象。

Array不能够随意添加和删除其中的项，而ArrayList可以在任意位置插入和删除项。



## 在 Queue 中 poll()和 remove()有什么区别？

poll()和remove()都将**移除**并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。



## 哪些集合类是线程安全的？

Vector：就比Arraylist多了个同步化机制（线程安全）。

Hashtable：就比Hashmap多了个线程安全。

ConcurrentHashMap:是一种高效但是线程安全的集合。

Stack：栈，也是线程安全的，继承于Vector。





## 迭代器 Iterator 是什么？



## Iterator 怎么使用？有什么特点？

遍历集合，可以删除迭代器指定的最后一个元素；



## Iterator 和 ListIterator 有什么区别？

- Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
- Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
- ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。



## 怎么确保一个集合不能被修改？

Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。

同理：Collections包也提供了对list和set集合的方法。
Collections.unmodifiableList(List)；//返回的是一个List实现类，方法实现中关于修改的方法全部throw异常 	
Collections.unmodifiableSet(Set)；



# 三、多线程

## 并行和并发有什么区别？

并发是多线程中的名词，多线程发生的过程是：多线程是通过线程轮流切换来获取CPU执行时间的；

一、区别：

并发是指一个处理器同时处理多个任务。 
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 
并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 

二、图解：

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。 

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825164818667-2129927824.png)

 

并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825164935572-1875514223.png)

并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。

三、在一个CPU或多个CPU的情况下：

当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。

当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。

![img](https://images2018.cnblogs.com/blog/1266222/201808/1266222-20180825165218443-1602996394.png)





## 线程和进程的区别？

1. 进程是**资源分配**的最小单位，线程是**程序执行**的最小单位（资源调度的最小单位）；
2. 进程有自己的**独立地址空间**，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
3. 线程是**共享进程中的数据**的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
4. **线程之间的通信更方便**，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
5. **多进程程序更健壮**，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间；



## 守护线程是什么？

java里线程分2种：

用户线程：应用程序里的线程，一般都是用户自定义线程；

守护线程（即daemon thread），专门用于服务其他的线程的线程，比如**垃圾回收线程**，就是最典型的守护线程。

1、守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。

 2、再换一种说法，如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。

 3、守护线程又被称为“服务进程”“精灵线程”“后台线程”，是指在程序运行是在后台提供一种通用的线程，这种线程并不属于程序不可或缺的部分。 通俗点讲，**任何一个守护线程都是整个JVM中所有非守护线程的“保姆”**。



## 创建线程有哪几种方式？

Java中创建线程主要有三种方式：

一、继承Thread类创建线程类

（1）定义**Thread类的子类**，重写run方法，run()方法称为执行体。

（2）创建Thread子类的实例，即创建了线程对象。

（3）调用线程对象的**start()**方法来启动该线程。

```Java
public class FirstThreadTest extends Thread {

    int i = 0;

    //重写run方法，run方法的方法体就是现场执行体
    public void run() {
        for (; i < 100; i++) {
            System.out.println(getName() + "  " + i);
        }
    }

    public static void main(String[] args) {

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "  : " + i);
            if (i == 50) {
                new FirstThreadTest().start();
                new FirstThreadTest().start();
            }
        }
    }
}
```

二、通过Runnable接口创建线程类

 （1）定义**runnable接口实现类**，**重写run()**方法，该run()方法的方法体同样是该线程的线程执行体。

 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

 （3）调用线程对象的**start()**方法来启动该线程。

```java
public class RunnableThreadTest implements Runnable{
        private int i;
        public void run()
        {
            for(i = 0;i <100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
        public static void main(String[] args)
        {
            for(int i = 0;i < 100;i++)
            {
                System.out.println(Thread.currentThread().getName()+" "+i);
                if(i==20)
                {
                    RunnableThreadTest rtt = new RunnableThreadTest();
                    new Thread(rtt,"新线程1").start();
                    new Thread(rtt,"新线程2").start();
                }
            }

        }
}
```

三、通过Callable和Future创建线程

 （1）创建**Callable接口的实现类**，并实现**call()**方法，该call()方法将作为线程执行体，并且有返回值。

 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值；

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable<Integer> {

    public static void main(String[] args) {
        CallableThreadTest ctt = new CallableThreadTest();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
            if (i == 20) {
                new Thread(ft, "有返回值的线程").start();
            }
        }
        try {
            System.out.println("子线程的返回值：" + ft.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception {
        int i = 0;
        for (; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        return i;
    }
}
```

**采用实现Runnable、Callable接口的方式创见多线程：**

***优势是：***

 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

 在这种方式下，**多个线程可以共享同一个target对象**，所以非常适合**多个相同线程来处理同一份资源**的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

 ***劣势是：*** 

编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

**使用继承Thread类的方式创建多线程时**

***优势是：***

编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

 ***劣势是：***

线程类已经继承了Thread类，所以不能再继承其他父类。

 



## 说一下 runnable 和 callable 有什么区别？

**相同点**：

1. 都是接口
2. 都可以编写多线程程序
3. 都采用Thread.start()启动线程

**不同点**

1. Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果；
2. Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛；

**注**：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。



## 线程有哪些状态？

![img](http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg)



**新建(NEW)**：新创建了一个线程对象。

**可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于*<u>可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</u>*

**运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

**阻塞(BLOCKED)**：阻塞状态是指线程<u>因为某种原因放弃了cpu 使用权</u>，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

(一). 等待阻塞：运行(running)的线程执行o<u>.wait()</u>方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该<u>同步锁被别的线程占用</u>，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行<u>Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时</u>，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

**死亡(DEAD)**：线程run()、main() 方法<u>执行结束，或者因异常退出了run()方法</u>，则该线程结束生命周期。死亡的线程不可再次复生。

![img](https://images2015.cnblogs.com/blog/987722/201610/987722-20161023195546779-1879243475.png)



## sleep() 和 wait() 有什么区别？

1、这两个方法来自不同的类分别是Thread和Object，sleep方法属于Thread类中的静态方法，wait属于Object的成员方法。
2、最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。



## notify()和 notifyAll()有什么区别？

当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争




## 线程的 run()和 start()有什么区别？

run()相当于线程的任务处理逻辑的入口方法，它由**Java虚拟机在运行相应线程时直接调用**，而不是由应用代码进行调用。每个线程都有要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或通过该方法进行调用。

start()的作用是**启动相应的线程**。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由**线程调度器**决定的。**start()调用结束并不表示相应线程已经开始运行**，这个线程可能稍后运行，也可能永远也不会运行。



## 创建线程池有哪几种方式？

![img](https://images2018.cnblogs.com/blog/683355/201808/683355-20180816144744665-1756137326.png)

各个类型的设计目的：

Executor是一个基础的接口，其初衷是将**任务提交和任务执行细节解耦**，这一点可以参考其定义的唯一方法。

　　void execute(Runnable command);

线程池的好处大致有三种：

1.  降低资源消耗；
2.  提高响应速度；
3.  提高线程的可管理性。使用线程池可以进行资源的统一分配、调优和监控。；

Java通过Executors提供四种线程池，分别为：

1. CachedThreadPool  **可缓存线程池**

   如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，**线程池的容量不限制；**

2. FixedThreadPool  **定长线程池**，

   每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程；
   可控制线程最大并发数，超出的线程会在队列中等待；

3. ScheduledThreadPool **定长线程池**

   定时及周期性任务执行。

4. SingleThreadExecutor **单线程化的线程池**

   单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行；
   例如监听进入的套接字连接的任务；
   对于希望在线程中运行的短任务同样也很方便，例如更新本地或远程日志的小任务，或者是事件分发线程。

5. newSingleThreadScheduledExecutor  **单线程化的线程池**

   单线程可执行周期性任务的线程池；

6. newWorkStealingPool **任务窃取线程池**

   不保证执行顺序，适合任务耗时差异较大。

   线程池中有多个线程队列，有的线程队列中有大量的比较耗时的任务堆积，而有的线程队列却是空的，就存在有的线程处于饥饿状态，当一个线程处于饥饿状态时，它就会去其它的线程队列中窃取任务。解决饥饿导致的效率问题。

   

## 线程池都有哪些状态？

![image](http://images.cnitblog.com/blog/497634/201401/08000847-0a9caed4d6914485b2f56048c668251a.jpg)

1、**RUNNING**

(1) 状态说明：线程池处在RUNNING状态时，**能够接收新任务，以及对已添加的任务进行处理**。 
(2) 状态切换：线程池的**初始化状态**是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

2、 **SHUTDOWN**

(1) 状态说明：线程池处在SHUTDOWN状态时，**不接收新任务，但能处理已添加的任务。** 
(2) 状态切换：调用线程池的**shutdown()**接口时，线程池由RUNNING -> SHUTDOWN。

3、**STOP**

(1) 状态说明：线程池处在STOP状态时，**不接收新任务，不处理已添加的任务，尝试打断正在执行的task
(2) 状态切换：调用线程池的**shutdownNow()**接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、**TIDYING**

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 
(2) 状态切换：当线程池在**SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空**时，就会由 SHUTDOWN -> TIDYING。 
当线程池在**STOP状态下，线程池中执行的任务为空时**，就会由STOP -> TIDYING。

5、 **TERMINATED**

(1) 状态说明：**线程池彻底终止**，就变成TERMINATED状态。 
(2) 状态切换：线程池处在TIDYING状态时，执行完**terminated()**之后，就会由 TIDYING -> TERMINATED。



## 线程池中 submit()和 execute()方法有什么区别？

execute开启线程执行池中的任务；

submit提交指定的任务去执行并且返回Future对象，即执行的结果。
通过捕获Future.get抛出的异常。

```java
package com.example.demo.test.threadpool;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class RunnableTestMain {

    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        /**
         * execute(Runnable x) 没有返回值。可以执行任务，但无法判断任务是否成功完成。
         */
        pool.execute(new RunnableTest("Task1"));

        /**
         * submit(Runnable x) 返回一个future。可以用这个future来判断任务是否成功完成。
         */
        Future future = pool.submit(new RunnableTest("Task2"));

        try {
            if(future.get()==null){//如果Future's get返回null，任务完成
                System.out.println("任务完成");
            }
        } catch (InterruptedException e) {
        } catch (ExecutionException e) {
            //否则我们可以看看任务失败的原因是什么
            System.out.println(e.getCause().getMessage());
        }
    }
}

class RunnableTest implements Runnable {

    private String taskName;

    public RunnableTest(final String taskName) {
        this.taskName = taskName;
    }

    @Override
    public void run() {
        System.out.println("Inside "+taskName);
        throw new RuntimeException("RuntimeException from inside " + taskName);
    }
}
```





## 在 java 程序中怎么保证多线程的运行安全？

## 多线程锁的升级原理是什么？

## 什么是死锁？

## 怎么防止死锁？

## ThreadLocal 是什么？有哪些使用场景？

ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。





## 说一下 synchronized 底层实现原理？

## synchronized 和 volatile 的区别是什么？

## synchronized 和 Lock 有什么区别？

## synchronized 和 ReentrantLock 区别是什么？

## 说一下 atomic 的原理？

# 四、反射

## 什么是反射？

反射指程序可以访问、检测、修改本身状态或行为的一种能力；

反射允许编写与执行时，使程序代码能够接入装载到JVM中类的内部信息；



## 什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成**字节流**的过程。

反序列化：将字节流转换成 Java 对象的过程。

当 Java 对象需要在**网络上传输 或者 持久化存储到文件中**时，就需要对 Java 对象进行序列化处理。

序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

注意事项：

- 某个类可以被序列化，则其子类也可以被序列化；

- 声明为 **static 和 transient 的成员变量，不能被序列化**。static 成员变量是描述类级别的属性，transient 表示临时数据；

- 反序列化读取序列化对象的顺序要保持一致；

  

## 动态代理是什么？有哪些应用？

根据对象在**内存中加载的Class类**创建运行时类对象，从而为其他对象提供一种代理以控制对这个对象的访问。

应用：
Spring的AOP，加事务，加权限，加日志。

扩展：

**静态代理**是自己手写一个代理类，代理类中直接调用目标方法，以及添加额外功能。

而动态代理则不用我们手写，而是依赖于java反射机制。

## 怎么实现动态代理？

JDK动态代理、CGLIB动态代理；

**JDK动态代理（类实现接口）**：可以直接使用，不依赖第三方。

```java
public final class XXX extends Proxy implements XXX
```

- 实现InvocationHandler接口，重写invoke方法；
- Proxy.newProxyInstance（）获取到代理对象；

```java
package com.example.demo.test.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JDKProxy {

    public static void main(String[] args) {

        JDKProxy jdkProxy = new JDKProxy();
        People proxy = jdkProxy.proxy();
        proxy.hello(" 谢 谢 ");
    }

    public People proxy() {

        People people = new Person();
        return (People) Proxy.newProxyInstance(people.getClass().getClassLoader(),
                new Class[]{People.class}, new CustomInvocationHandler(people));
    }
}

class CustomInvocationHandler implements InvocationHandler {

    private Object people;
    public CustomInvocationHandler(Object people) {
        this.people = people;
    }
    /**
     * proxy : 把代理对象自己传递进来 
     * method：把代理对象当前调用的方法传递进来 
     * args:把方法参数传递进来
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("被代理了的参数" + args.length);
        return method.invoke(people, args);
    }
}

class Person implements People {

    public String hello(String a) {
        System.out.println("方法参数" + a);
        return a.trim();
    }
}

interface People {
    String hello(String a);
}
```

CGLIB动态代理：

继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。
根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。

- 实现MethodInterceptor接口，重写intercept方法；
- 设置代理类，Enhancer.setSuperclass(UserServiceImpl.class);
- 设置回调方法，Enhancer.setCallback(new CustomMethodInterceptor())；
- 创建代理类，Enhancer.create()

```java
package com.example.demo.test.proxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CglibProxy {

    public static void main(String[] args) {

        Enhancer enhancer = new Enhancer();
        //继承被代理类
        enhancer.setSuperclass(UserServiceImpl.class);
        // 设置回调方法
        enhancer.setCallback(new CustomMethodInterceptor());
        // 创建代理对象
        UserServiceImpl userServicer = (UserServiceImpl)enhancer.create();
        userServicer.addUser();
    }
}

class CustomMethodInterceptor implements MethodInterceptor{

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("事务开始。。。");
        Object result = proxy.invokeSuper(o, args);
        System.out.println("事务结束。。。");
        return result;
    }
}

/**
 * 业务类没有实现接口
 * 如果类是final的，则无法生成代理对象，报错
 * 如果方法是final的，代理无效
 */
class UserServiceImpl {
    
    public void addUser() {
        System.out.println("增加一个用户。。。");
    }
}
```

jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的**大部分类是直接对Java字节码进行操作**，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib。



# 五、对象拷贝

## 为什么要使用克隆？

clone方法是在复制一个对象，赋值的对象是单独独立的，有独自的内存空间。

clone方法是java中顶层父类Object中的一个方法，此方法在java中为实现，是一个native方法，也就是本地方法（可以调用底层操作系统的方法），在调用本地方法创建对象，比直接new创建对象效率高。



## 如何实现对象克隆？

两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。
在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。
有两种方式：

1. 实现**Cloneable接口**并重写Object类中的clone()方法；

   - 实现Cloneable接口；
   - 重载Object类中的clone()方法，重载时需定义为public；
   - 在重载方法中，调用super.clone()；

   ```java
   public Object clone() {
           Student o = null;
           try {
               o = (Student) super.clone();
           } catch (CloneNotSupportedException e) {
               System.out.println(e.toString());
           }
           o.p = (Professor) p.clone();//要克隆的对象中引用类型
           return o;
       }
   ```

   

2. 实现**Serializable接口**，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆；

   - 实现Serializable接口；
   - ByteArrayOutputStream和ObjectOutputStream.writeObject方法序列化对象；
   - ByteArrayInputStream和ObjectInputStream.readObject()反序列化对象得到克隆对象；

```java
public Object deepClone() throws IOException, OptionalDataException,
            ClassNotFoundException {
        // 将对象写到流里
        ByteArrayOutputStream bo = new ByteArrayOutputStream();
        ObjectOutputStream oo = new ObjectOutputStream(bo);
        oo.writeObject(this);//this指要克隆的对象
        // 从流里读出来
        ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
        ObjectInputStream oi = new ObjectInputStream(bi);
        return (oi.readObject());
    }
```



# 六、Java Web

## jsp 和 servlet 有什么区别？

jsp和servlet的区别和联系：

1.jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)

2.jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.

3.Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.

Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。
联系：  JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑



## jsp 有哪些内置对象？作用分别是什么？

**request：**表示HttpServletRequest对象，用户端请求。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。

**response：**表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等），网页传回用户端的回应

**out：**对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。

**pageContext：**表示一个javax.servlet.jsp.PageContext对象。该对象提供了对JSP页面内所有的对象及名字空间（就是四大作用域空间，如page空间、request空间、session空间、application空间）的访问，也就是说他可以访问到当前请求对应session中保存的信息，也可以取当前应用所在的application的某一属性值，它相当于页面中所有功能的集大成者，包装了通用的servlet相关功能的方法。

**session：**表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息

**applicaton：**表示一个javax.servle.ServletContext对象。类似于系统的全局变量，用于实现Web应用中的资源共享。

**config：**表示一个javax.servlet.ServletConfig对象。用于存放JSP编译后的初始数据。

**page：**表示从该页面产生的一个servlet实例，JSP网页本身

**exception：**针对错误网页，未捕捉的例外。表示JSP页面运行时产生的异常和错误信息，该对象只有在错误页面（page指令中设定isErrorPage为true的页面）中才能够使用。

注意到:

四大作用域：pageContext request session application 可以通过 jstl从四大作用域中取值.

request session application 用于jsp递值 



## 说一下 jsp 的 4 种作用域？

page、request、session、application

**Page**：用户请求的当前页面；

**Request**：用户请求访问的当前组件，以及和当前web组件共享同一用户请求的web组件。如：被请求的jsp页面和该页面用<include>指令包含的页面以及<forward>标记包含的其它jsp页面； 

**Session**：同一个http会话中的web组件共享它；
**Application**：整个web应用的所用web组件共享它。



## session 和 cookie 有什么区别？

cookie与session的区别有：

cookie以文本格式存储在浏览器上，存储量有限；

session 存储在服务端，可以无限量存储多个变量并且比cookie更安全；

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=635969339,977853545&fm=173&app=49&f=JPEG?w=640&h=256&s=802274329FE04D01464931DA0300D0B0)

![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2169381799,1320776160&fm=173&app=49&f=JPEG?w=450&h=300&s=440A5532435E4DC80AD4B1DB0000C0B2)



**session与cookie的区别**

（1）Cookie以文本文件格式存储在浏览器中，而session存储在服务端，通常是保存在内存中，当然也可以保存在文件、数据库等等。客户端跟服务器端通过SessionId来关联，SessionId通常以Cookie的形式存储在客户端。每次HTTP请求，SessionId都会随着Cookie被传递到服务器端，这行就可以通过SessionId取到对应的信息，来判断这个请求来自于哪个客户端/用户。

（2）cookie的存储限制了数据量，只允许4KB，而session是无限量的

（3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全

（4）设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。





## 说一下 session 的工作原理？

![img](https://img-blog.csdnimg.cn/20190105150030891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTYwNTkzNw==,size_16,color_FFFFFF,t_70)



```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    req.setCharacterEncoding("utf-8");
    resp.setContentType("text/html;charset=utf-8");
    //创建session
    HttpSession session=req.getSession();
    session.setAttribute("name", "周博");
}

protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
 {
    req.setCharacterEncoding("utf-8");
    resp.setContentType("text/html;charset=utf-8");
    HttpSession session=req.getSession();
    PrintWriter out=resp.getWriter();
        out.println(session.getAttribute("name"));
}
```





## 如果客户端禁止 cookie 时， session 还能用吗？

如果是浏览器禁用了cookie功能，也就只能够使用URL重写来实现session存储的功能；

通常情况下，SessionId均由Cookie负责保存，但是客户端跟服务器端通过HTTP交互，除了Cookie可以携带信息之外，URL也可以。不过对用户不友好，所以基本上没有互联网项目会采用这种方案。



## spring mvc 和 struts 的区别是什么？

## 如何避免 sql 注入？

## 什么是 XSS 攻击，如何避免？

## 什么是 CSRF 攻击，如何避免？

# 七、异常

![img](https://img-blog.csdn.net/20170622192453860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjI4NjAzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

所有抛出的异常都是从Throwable派生而来。类Throwable有两个直接子类：Error和Exception；

Error类对象由虚拟机生成并抛出，比如内存泄漏，通常Java程序不对这类异常进行处理；

运行时异常和非运行时异常：

继承自RuntimeException是**运行时异常，unchecked  exceptions**，不必处理，比如空指针异常，非法参数异常，类找不到异常，NullPointerException(空指针异常)、 
IndexOutOfBoundsException(下标越界异常) 、
ClassCastException(类转换异常) 、
ArrayStoreException(数据存储异常，操作数组时类型不一致) 、
IO操作的BufferOverflowException异常 、

其他为**非运行时异常，checked   exceptions**，需要处理，如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

## throw 和 throws 的区别？

throw用于方法体内部，用来抛出一个Throwable类型的异常。

​	如果抛出了检查性异常，则还应该在头部声明方法可能抛出的异常类型，该方法调用者也必须检查处理抛出的异常。

​	如果抛出的是非检查型异常或者Error，该方法的调用者可以选择处理该异常。

throws用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。



## final、finally、finalize 有什么区别？

**final：**

​	修饰成员：变量一旦被初始化便不可更改，对于基本类型来时是值不可变，对于对象变量来说是引用不可变，初始化可以在两个地方，一个是定义处，一个是构造器内；

​	修饰方法：方法无需再进行扩展，继承此类的类可以继承这个方法，但是不能重写这个方法。

​		允许编译器将所有对此方法的调用转为行内调用，直接将方法主体插入到调用处，可以省略保存断点，压栈		等步骤，使程序效率有所提高。但是当方法主体庞大时，反而会影响效率，慎用。

​	修饰类：类不可被继承，类不需要进行修改和扩展时使用。类上加final，成员变量可以定义final或者不定义，

​	但是方法默认为final；

**finally：**

​	finally结构使代码总会执行，不管有无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。finally只有一种情况不会执行。当执行到System.exit(0);finally不会执行。

​	finally代码块中有异常的时候，try和catch块中的异常无法抛出，但是try和catch中的代码可以正常执行；

**finalize：**

​	方法是在Object中定义的，垃圾回收器在确定对象没有被引用时，也就是清理对象之前对这个方法进行调用，Object中定义的方法体为空，子类继承这个方法可以实现垃圾回收器在将对象从内存清除出去之前整理系统资源或者其他的清理工作。



## try-catch-finally 中哪个部分可以省略？

catch和finally语句不能同时省略！！！ 



## try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

会；

**特殊实例：**

finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。finally还可以改变引用类型的值；

```Java
public static void main(String[] args) {
        int k = f_test();
        System.out.println(k);
    }

    public static int f_test(){
        int a = 0;
        try{
            a = 1;
            return a;
        }
        finally{
            System.out.println("It is in final chunk.");
            a = 2;
            return a;
        }
    }
/*输出： 
It is in final chunk.
2*/
```



## 常见的异常类有哪些？

**运行时异常：**

ArithmeticException——由于除数为0引起的异常；

ArrayStoreException——由于数组存储空间不够引起的异常；

ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常；

IllegalMonitorStateException——监控器状态出错引起的异常；

NegativeArraySizeException—一数组长度是负数，则产生异常；

NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； OutofMemoryException——用new语句创建对象时，如系统无法为其分配内存空 间则产生异常；

SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常；

IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常；

IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常；

ClassNotFoundException——未找到指定名字的类或接口引起异常；

CloneNotSupportedException——一程序中的一个对象引用Object类的clone方法，但 此对象并没有连接Cloneable接口，从而引起异常；

InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述；

NoSuchMethodException一所调用的方法未找到，引起异常；

Illega1AccessExcePtion—一试图访问一个非public方法；

StringIndexOutOfBoundsException——访问字符串序号越界，引起异常；

ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常；

NumberFormatException——字符的UTF代码数据格式有错引起异常；

IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常；

FileNotFoundException——未找到指定文件引起异常；

EOFException——未完成输入操作即遇文件结束引起异常。

**非运行时异常：**

IOException；

SqlException；



# 八、网络

## http 响应码 301 和 302 代表的是什么？有什么区别？

  301 redirect: 301 代表永久性转移(Permanently Moved)；

  302 redirect: 302 代表暂时性转移(Temporarily Moved )；

详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址**；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址。**





## forward 和 redirect 的区别？

是servlet种的两种主要的跳转方式，forward又叫转发，redirect叫做重定向。

两者的区别总结：

1. 从地址栏显示来说：

1）forword是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。

2）redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的地址。

2。 从数据共享来说：

1）由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用。即可以共享数据

2）redirect不能共享

3. 从运用的地方来说

1）forword 一般用于用户登录的时候，根据角色转发到相应的模块

2） redirect一般用于用户注销登录时返回主页面或者跳转到其他网站

4。 从效率来说：

1）forword效率高，而redirect效率低

5. 从本质来说：

forword转发是服务器上的行为，而redirect重定向是客户端的行为
![img](https://img-blog.csdn.net/20180519161921525?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2NjI5Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

6. 从请求的次数来说：

forword只有一次请求；而redirect有两次请求，



## 简述 tcp 和 udp的区别？

## tcp 为什么要三次握手，两次不行吗？为什么？

## 说一下 tcp 粘包是怎么产生的？

## OSI 的七层模型都有哪些？

![img](https://img-blog.csdn.net/20180930214143743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbmNlbjEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**物理层**：设备之间比特流的传输，物理接口，电气特性等等。常见的设备有网线，网卡等等。数据单位是比特

**数据链路层**：成帧，用Mac地址访问媒介，错误检测与修正。数据单位是帧

**网络层**：提供逻辑地址（IP地址）、选路（选择传输路线）。数据单位是报文

**传输层**：确定传输的可靠性以及每种协议的端口号，传输前的错误检测，流控。数据单位是TPDU

**会话层**：对应用会话的管理，同步。确定网络数据是否要经过远程会话 。数据单位是SPDU

**表示层**：数据的表现形式，特定功能的实现，比如加密压缩等。数据单位是PPDU

**应用层**：用户接口，无限接近用户。数据单位是APDU

其中应用层、表示层和会话层是为用户提供服务的。传输层、网络层、数据链路层和物理层是为传输数据提供服务的。

![1573377437597](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573377437597.png)





## get 和 post 请求有哪些区别？

1. GET**参数**通过URL传递，POST放在Request body中。
2. GET请求在URL中传送的**参数是有长度**限制的，而POST没有。
3. GET比POST更**不安全**，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 
4. GET在浏览器回退时是无害的，而POST会再次提交请求。
5. GET产生的URL地址可以被Bookmark，而POST不可以。
6. GET请求会被**浏览器主动cache**，而POST不会，除非手动设置。
7. GET请求只能进行url编码，而POST支持多种编码方式。
8. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
9. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。



## 如何实现跨域？

跨域：当浏览器执行脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。

这里的同源指访问的**协议、域名、端口**都相同。**localhost和127.0.0.1虽然都指向本机，但也属于跨域。**
同源策略是由 Netscape 提出的著名安全策略，是浏览器最核心、基本的安全功能，它限制了一个源中加载脚本与来自其他源中资源的交互方式。
Ajax 发起的跨域 HTTP 请求，结果被浏览器拦截，同时 Ajax 请求不能携带与本网站不同源的 Cookie。

<script> <img> <iframe> <link> <video> <audio> 等带有 src 属性的标签可以从不同的域加载和执行资源。

1、jsonp
利用了 script 不受同源策略的限制
缺点：只能 get 方式，易受到 XSS攻击

3、代理跨域请求
前端向发送请求，经过代理，请求需要的服务器资源
缺点：需要额外的代理服务器



## 说一下 JSONP 实现原理？

**jsonp通过在服务端用一个回调函数把数据一起包裹起来并返回给客户端（jsonp名字就是这样来的json padding），然后客户端写好回调（处理数据），并动态创建一个script节点，通过src属性来调用服务端返回的回调函数。**

　　JSONP就像是JSON+Padding一样(Padding这里我们理解为填充)， 

<script>标签的src属性并不被同源策略所约束，所以可以获取任何服务器上脚本并执行。




程序A中sample的部分代码：

```javascript
<script type="text/javascript">
//回调函数
function callback(data) {
    alert(data.message);
}
</script>
<!--服务A引用服务B的资源-->
<script type="text/javascript" src="http://localhost:20002/test.js"></script>
```

程序B中test.js的代码：

```javascript
//调用callback函数，并以json数据形式作为阐述传递，完成回调

callback({message:"success"});
```

这其实就是JSONP的简单实现模式，或者说是JSONP的原型：**创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，完成回调。**

**将JSON数据填充进回调函数**，这就是JSONP的JSON+Padding的含义吧。

## HTTPS

HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。

![img](https://img-blog.csdn.net/20180420182717649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTk4MTUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**共享密钥加密（对称密钥加密）**：加密和解密同用一个密钥。加密时就必须将密钥传送给对方，那么如何安全的传输呢？

**公开密钥加密（非对称密钥加密）**：公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用此加密方式，发送密文的一方使用公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听盗走。

但由于公开密钥比共享密钥要慢，所以我们就需要综合一下他们两者的优缺点，使他们共同使用，而这也是HTTPS采用的加密方式。在交换密钥阶段使用公开密钥加密方式，之后建立通信交换报文阶段则使用共享密钥加密方式。


 这里就有一个问题，如何证明公开密钥本省是货真价实的公开密钥。如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输过程中，真正的公开密钥已经被攻击者替换掉了。为了解决这个问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其他相关机关颁发的公开密钥证书。

接收到证书的客户端可以使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可以明确两件事：

一、认证服务器的公开密钥的是真实有效的数字证书认证机构。

二、服务器的公开密钥是值得信赖的。

此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。

协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。

加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。

## TCP的三次握手与四次挥手理解（很全面）

https://blog.csdn.net/qq_38950316/article/details/81087809







# 九、设计模式

## 说一下你熟悉的设计模式？

**代理模式**：

​	概念：给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

​	作用：

​		**中介隔离作用：**在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户		类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。

​		**开闭原则，增加功能：**代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来**扩展委托类的功能**，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。

​	代理模式：

​		静态代理、动态代理（JDK代理，Cglib代理）

**装饰模式：**

装饰模式的特点：装饰类和被装饰类都必须所属同一个接口或者父类。 

 **装饰设计模式的简易代码：**

```java
public class PersonDemo {
    public static void main(String[] args){
        Person p = new Person();
        p.chifan();
        NewPerson p1 = new NewPerson(p);
        p1.chifan();
        NewPerson2 p2 = new NewPerson2();
        p2.chifan();
    }
}
class Person{
    void chifan(){
        System.out.println("吃饭");
    }
}
//这个类的出现是为了增强Person而出现的。
class NewPerson{
    private Person p ;
    NewPerson(Person p){
        this.p = p;
    }
    public void chifan(){
        System.out.println("开胃酒");
        p.chifan();
        System.out.println("甜点");
    }
}
class NewPerson2 extends Person{
    public void chifan(){
        System.out.println("开胃酒");
        super.chifan();
        System.out.println("甜点");
    }
}
```

​	NewPerson是对Person采用了装饰设计模式对Person对象的功能，NewPerson2是继承了Person，对对象的功能进行增强。

例IO类：

```
FileInputStream
  BufferedInputStream 
```

装饰和继承都能实现一样的特点：进行功能的扩展增强，但是他们之前是有区别的，装饰更加灵活。





## 简单工厂和抽象工厂有什么区别？



# 十、Spring/Spring MVC

## 为什么要使用 spring？

它提供了一个Web应用程序的基本框架；

1. Spring提供一个容器/工厂，**统一管理模块的定义，根据需要创建**。

2. 把模块的配置参数统一管理，模块不需要自行读取配置。

3. Spring提供依赖注入，把**依赖的模块自动**推送进来，不需要模块自己拉取。

4. 此外，Spring提供了对**很多其他第三方框架**的集成功能，减少了样板代码（boilerplate）。

   

## 解释一下什么是 aop？

AOP意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

概念：
1）**方面**（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。
2）**切入点**（Pointcut）：指定一个通知将被引发的一系列连接点的集合。
3）**连接点**（Joinpoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。
4）**通知**（Advice）：在特定的连接点，AOP框架执行的动作。
5）**目标对象**（Target Object）：包含连接点的对象，也被称作被通知或被代理对象。
6）**AOP代理**（AOP Proxy）：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。
7）**引入**（Introduction）：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。
8）**编织**（Weaving）：组装方面来创建一个被通知对象。

常见应用场景：
权限控制、异常处理、缓存、事务管理、日志记录、数据校验等等

AOP代理对象的生成：
Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。



## 解释一下什么是 ioc？

**IOC的别名：依赖注入(DI)**

依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指**通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦**。

**控制反转**：

​	控制权限由应用程序转移到IOC容器，组件不是由IOC容器创建和配置，而是由IOC容器负责；

**依赖注入**：

​	将调用者所依赖的类，在程序运行期间，由容器自动填充给调用者；



IOC中最基本的技术就是“**反 射(Reflection)**”编程；



## spring 有哪些主要模块？

**Spring有七大功能模块，分别是Spring Core，AOP，ORM，DAO，MVC，WEB，Content。** 

1. **Spring Core** ：
   Core模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Sprign的所有功能都是借助IOC实现的。

   ```
   IOC的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器负责将这些联系在一起。  
   ```

2. **AOP模块**
   是Spring的AOP库，提供了AOP（拦截器）机制，并提供常用的拦截器，供用户自定义和配置。 

   ```
   AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。  
   主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等  
   ```

3. **ORM** 模块** 
   Spring 的ORM模块提供对常用的ORM框架的管理和辅助支持，Spring支持常用的Hibernate，ibtas，jdao等框架的支持，Spring本身并不对ORM进行实现，仅对常见的ORM框架进行封装，并对其进行管理。 

4. **DAO模块** 
   Spring 提供对JDBC的支持，对JDBC进行封装，允许JDBC使用Spring资源，并能统一管理JDBC事物，并不对JDBC进行实现。 

5. **WEB模块** 

   WEB模块提供对常见框架如Struts1，WEBWORK（Struts 2），JSF的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器。 

6. **Context模块** 
   Context模块提供框架式的Bean访问方式，其他程序可以通过Context访问Spring的Bean资源，相当于资源注入。 

7. **MVC模块** 
   WEB MVC模块为Spring提供了一套轻量级的MVC实现，在Spring的开发中，我们既可以用Struts也可以用Spring自己的MVC框架，相对于Struts，Spring自己的MVC框架更加简洁和方便。



## **Spring中bean的生命周期**

在Web应用程序启动过程中，Spring容器中的每个bean也有各自的初始化顺序。一个bean，从bean definition被加载到初始化完成，按照以下顺序执行：

1. BeanFactory加载完bean definition和class，实例化除了bean对象。

2. 检查有没有实现BeanNameAware，有则调用setBeanName（得到bean id）

3. 检查有没有实现BeanClassLoaderAware，有则调用setBeanClassLoader。

4. 检查有没有实现EnvironmentAware，有则调用setEnvironment。

5. 检查有没有实现EmbeddedValueResolverAware，有则调用setEmbeddedValueResolver。

6. 检查有没有实现ResourceLoaderAware，有则调用setResourceLoader。

7. 检查有没有实现ApplicationEventPublisherAware，有则调用setApplicationEventPublisher。

8. 检查有没有实现MessageSourceAware，有则调用setMessageSource。

9. 检查有没有实现ApplicationContextAware，有则调用setApplicationContext。

10. 检查有没有实现ServletContextAware，有则调用setServletContext。

11. 调用BeanPostProcessors中的所有postProcessBeforeInitialization，对bean进行一些更进一步的配置。

12. 调用InitializingBean接口中的afterPropertiesSet执行bean自身提供的初始化代码。

13. 调用通过其他方式指定的init-method方法，执行bean自身的初始化。

14. 调用BeanPostProcessors中的所有postProcessAfterInitialization方法。



流程：

\1. 扫描scan

\2. 解析信息 parse（不能直接new的类，懒加载和原型）

\3. 信息缓存 cache

\4. BeanFactoryPostProcessor

\5. new



## spring 常用的注入方式有哪些？

**三种注入方式**：

**set方法注入**；

**构造方法注入**；

**接口注入**：

​	要求bean类实现接口，入侵性强，与spring设计初衷不符。



## @Autowired和@Resource区别？

@Autowired自动装配（注解是属业spring）：

- **默认根据类型**注入，可以用于构造器、接口、方法注入；
- 默认required=true，如果允许出现0个Bean候选者需要设置属性“required=false”；

@Autowired是根据类型进行自动装配的。如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出BeanCreationException异常;如果Spring上下文中不存在UserDao类型的bean，也会抛出BeanCreationException异常。我们可以使用@Qualifier配合@Autowired来解决这些问题。如下：

```java
@Autowired   
@Qualifier("userServiceImpl")   
public IUserService userService;   
```

@Resource（注解属于J2EE）：

可以标注在字段或属性的setter方法上，但它**默认按名称装配**。

- 名称可以通过@Resource的name属性指定；
- 当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象；
- 当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象；
- 如果没有找到该名称，则会按照类型去寻找；



## spring 中的 bean 是线程安全的吗？

Spring Bean是非线程安全的。

**单实例 singleton（缺省）**：

在整个Spring IoC容器里，只有一个bean实例，所有线程共享该实例；

 **原型实例prototype：**

每次请求都会创建并返回一个新的实例，所有线程都有单独的实例使用，这种方式是比较安全的，但会消耗大量内存和计算资源。



## spring 支持几种 bean 的作用域？

当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下**5种**作用域：

- **singleton**：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例
- **prototype**：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例
- **request**：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效
- **session**：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效
- **globalsession**：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效。



## spring 装配 bean 有哪些方式？

1. 在XML中进行显式配置；
2. 在java中进行显式配置；
3. 隐式的bean发现和自动装配（一般推荐使用自动装配bean的方式）；

**XML配置**：

（1）创建一个xml文件，以<beans>为根元素创建。在使用xml的时候，需要在配置文件的最上部声明多个xml模式，这些文件定义了配置spring的XML元素。
 （2）使用<bean>元素来声明一个bean，我们可以给其加一个id，来表示bean的id，class属性表示这个类，并且需要使用全限定的类名。
 （3）构造器注入：<constructor-arg>元素或者spring的c命名空间。c命名来声明构造器参数，作为<bean>元素的一个属性。

（4）字面量的注入，可以采用<constructor-arg>元素的value属性，表示该属性表明给定的值以字面量的形式注入到构造器中。c命名的方式为c:参数索引来装配相同的字面量值。其中XML不允许某个元素的多个属性具有相同的名字。
 （5）集合装配，<list>元素是<constructor-arg>的子元素，表明一个包含值的列表将会传递到构造器中，其中<value>元素用来指定列表中的每个元素。也可以使用<ref bean="">的方式来代替<value>元素。<set>元素也可以，只是<list>和<set>元素还是有区别的，<set>元素会忽略掉所有重复的值，存放顺序也不可以保证。
 （6）属性注入，对于强依赖我们一般用构造器注入，对于非强依赖，我们一般选用属性注入的方式。<property>元素name属性和ref属性，通过ref属性来引用bean，通过name属性来注入。其实，我们也可以采用spring 的p命名空间来替代<property>元素。

**java类配置**：

（1）创建配置类，使用**@Configuration**注解，表示该类是一个配置类。
（2）使用**@Bean**注解创建Bean，该注解会告诉Spring这个方法将会返回一个对象，该对象要注册为spring引用上下文中的bean，方法体重包含了最终产生的bean实例的逻辑。默认情况下Bean的id和@Bean的注解的方法名一致，也可以通过设置@Bean注解的name属性来设置bean的名字。
（3）注入，引用创建bean的方法。默认情况下，spring中的bean都是单例的。

**bean自动装配**：

（1）组件扫描：spring会自动发现应用上下文中所创建的bean。
		类上面使用**@Component**注解，**@ComponentScan**注解，该注解可以在spring中启动组件扫描。

（1）自动装配：spring自动满足bean之间的依赖。**@Autowired**和@Resource注解；



## spring 自动装配 bean 有哪些方式？

在Spring中，我们有4种方式可以装配Bean的属性。

**1，byName**

通过byName方式自动装配属性时，是在定义Bean的时候，在property标签中设置autowire属性为byName，那么Spring会自动寻找一个与该属性名称相同或id相同的Bean，注入进来。

**2，byType**

通过byType方式自动注入属性时，是在定义Bean的时候，在property标签中设置autowire属性为byType，那么Spring会自动寻找一个与该属性类型相同的Bean，注入进来。

**3，constructor**

通过构造器自动注入。在定义Bean时，在bean标签中，设置autowire属性为constructor，那么，Spring会寻找与该Bean的构造函数各个参数类型相匹配的Bean，通过构造函数注入进来。

**4，autodetect**

自动装配。如果想进行自动装配，但不知道使用哪种类型的自动装配，那么就可以使用autodetect，让容器自己决定。这是通过在定义Bean时，设置bean标签的autowire属性为autodetect来实现的。设置为autodetect时，Spring容器会首先尝试构造器注入，然后尝试按类型注入。

默认情况下，Spring是不进行自动装配的。我们可以在xml中，设置beans标签的default-autowire属性为byName，byType等，来设置所有bean都进行自动装配。



## spring 事务实现方式有哪些？

（1）编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。
（2）基于 TransactionProxyFactoryBean的声明式事务管理
（3）基于 @Transactional 的声明式事务管理
（4）基于Aspectj AOP配置事务



## 说一下 spring 的事务隔离？

（1）读未提交read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。

（2）读提交 read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。使用最多；

（3）可重复读 repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。

（4）serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读

脏读、不可重复读、幻象：
a**.脏读**：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。

b.**不可重复读**：指在一个事务内，多次读同一数据。
在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。

c.**幻象读**：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）


1. Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE. Oracle 默认的事务隔离级别为: READ COMMITED   

2. Mysql 支持 4 中事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ  ；

   

## 说一下 spring mvc 运行流程？

1、 用户向服务器发送请求，请求被 Spring 前端控制 Servelt DispatcherServlet 捕获(捕获)

2、 DispatcherServlet对请求  URL进行解析，得到请求资源标识符（URI）。然后根据该  URI，调用 HandlerMapping获得该Handler配置的所有相关的对象（包括  Handler对象以及   Handler对象对应的拦截器），最后以 HandlerExecutionChain对象的形式返回；(查找   handler)

3、 DispatcherServlet  根据获得的 Handler，选择一个合适的  HandlerAdapter。  提取Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller), Handler执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象(执行  handler)

4、DispatcherServlet  根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver) (选择  ViewResolver)

5、通过 ViewResolver 结合 Model 和 View，来渲染视图,DispatcherServlet 将渲染结果返回给客户端。（渲染返回）



核心控制器捕获请求、查找Handler、执行Handler、选择ViewResolver,通过ViewResolver渲染视图并返回；



## spring mvc 有哪些组件？

前端控制器（DispatcherServlet） 
处理器映射器（HandlerMapping） 
处理器适配器（HandlerAdapter） 
拦截器（HandlerInterceptor）
语言环境处理器（LocaleResolver）
主题解析器（ThemeResolver）
视图解析器（ViewResolver） 
文件上传处理器（MultipartResolver）
异常处理器（HandlerExceptionResolver） 
数据转换（DataBinder）
消息转换器（HttpMessageConverter）
请求转视图翻译器（RequestToViewNameTranslator）
页面跳转参数管理器（FlashMapManager）
处理程序执行链（HandlerExecutionChain） 





## @RequestMapping 的作用是什么？





# 十一、Spring Boot/Spring Cloud

## 什么是 spring boot？

SpringBoot是一个框架，一种全新的编程规范,简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。



## 为什么要用 spring boot？

让文件配置变的相当简单;

让应用部署变的简单（SpringBoot内置服务器，并装备启动类代码），可以快速开启一个Web容器进行开发。

- 独立运行
- 简化配置
- 自动配置
- 无代码生成和XML配置
- 应用监控
- 上手容易

```
Spring Boot会根据项目中依赖的jar包自动配置项目的配置项，* 比如：添加了spring-boot-starter-web的依赖，项目中也就会引入SpringMVC的依赖，并且Spring Boot会自动配置tomcat 和SpringMVC。
```

## spring boot 核心配置文件是什么？

Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。

application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。

bootstrap 配置文件有以下几个应用场景。

- 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
- 一些固定的不能被覆盖的属性；
- 一些加密/解密的场景;



## spring boot 配置文件有哪几种类型？它们有什么区别？

Spring Boot会自动加载classpath目前下的这两个文件，文件格式为 properties 或 yml 格式；



## spring boot 有哪些方式可以实现热部署？

第一种：依赖**spring-boot-devtools**实现，将以下代码放到dependencies中：

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

第二种：在 spring-boot-maven-plugin 插件配置中添加 **springloaded** 依赖。

```java
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <dependencies>
                <dependency>
                    <groupId>org.springframework</groupId>
                    <artifactId>springloaded</artifactId>
                    <version>1.2.5.RELEASE</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>
```

**必须通过mvn spring-boot:run 命令启动应用， 修改代码或页面才会更新。**



## jpa 和 hibernate 有什么区别？

## 什么是 spring cloud？

Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：

- eureka (提供服务注册与发现功能)
- ribbon（提供负载均衡功能）
- Feign（整合了ribbon和Hystrix，具有负载均衡和熔断限流等功能）
- Hystrix （提供了熔断限流，合并请求等功能）
- Zuul （提供了智能路由的功能）
- Hystrix Dashboard （提供了服务监控的功能，提供了数据监控和友好的图形化界面）
- Hystrix Turbine （Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。也是监控系统的功能）
- spring cloud config （提供了统一配置的功能）
- Spring Cloud Bus （提供了配置实时更新的功能）



## spring cloud 断路器的作用是什么？

## spring cloud 的核心组件有哪些？

# 十二、Hibernate

## 为什么要使用 hibernate？

## 什么是 ORM 框架？

## hibernate 中如何在控制台查看打印的 sql 语句？

## hibernate 有几种查询方式？

## hibernate 实体类可以被定义为 final 吗？

## 在 hibernate 中使用 Integer 和 int 做映射有什么区别？

## hibernate 是如何工作的？

## get()和 load()的区别？

## 说一下 hibernate 的缓存机制？

## hibernate 对象有哪些状态？

## 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

## hibernate 实体类必须要有无参构造函数吗？为什么？

# 十三、Mybatis

## mybatis底层原理？

四大对象是指：executor, statementHandler,parameterHandler，resultHandler对象。

```java
//ParameterHandler 处理sql的参数对象
public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
    //包装参数插件
    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
    return parameterHandler;
}

//ResultSetHandler 处理sql的返回结果集
public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
                                            ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    //包装返回结果插件
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
}

//StatementHandler 数据库的处理对象
public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    //包装数据库执行sql插件
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
}

public Executor newExecutor(Transaction transaction) {
    //创建Mybatis的执行器：Executor
    return newExecutor(transaction, defaultExecutorType);
}

public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    //mybatis支持的三种执行器：batch、reuse、simple，其中默认支持的是simple
    if (ExecutorType.BATCH == executorType) {
        executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
        executor = new ReuseExecutor(this, transaction);
    } else {
        executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
        executor = new CachingExecutor(executor);
    }
    //包装执行器插件
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}

```

## Mybatis 作用域和生命周期？

**SqlSessionFactoryBuilder**

这个类可以在任何时候被实例化、使用和销毁。一旦您创造了就不需要再保留它了。所以 SqlSessionFactoryBuilder 实例的最好的作用域是方法体内（即一个本地方法变量）。您能重用 SqlSessionFactoryBuilder 创建多个 SqlSessuonFactory 实例，但最好不要把时间、资源放在解析 XML 文件上，而是要从中解放出来做最重要事情。

 

**SqlSessionFactory**

一旦创建，将会存在于您的**应用程序整个运行生命周期**中。很少或根本没有理由去销毁它或重新创建它。最佳实践是不要在一个应用中多次创建 SqlSessionFactory。这样做会被视为"没品味"。所是 SqlSessionFactory 最好的作用域范围是一个应用的生命周期范围。这可以由多种方式来实现，最简单的方式是使用 Singleton 模式或静态 Singleton 模式。但这不是被广泛接受的最佳做法，相反，您可能更愿意使用像 Goole Guice 或 Spring 的依赖注入方式。这些框架允许您创造一个管理器，用于管理 SqlSessionFactory 的生命周期。

 

**SqlSession**

**每个线程都有一个  SqlSession 实例**，SqlSession 实例是不被共享的，并且不是线程安全的。因此最好的作用域是 request 或者 method，决不要用一个静态字段或者一个类的实例字段来保存  SqlSession 实例引用。也不要用任何一个管理作用域，如 Servlet 框架中的 HttpSession，来保存 SqlSession 的引用。如果您正在用一个 WEB 框架，可以把 SqlSession 的作用域看作类似于 HTTP 的请求范围。也就是说，在收到一个HTTP请求，您可以打开一个SqlSession，当您把 response 返回时，就可以把 SqlSession 关闭。关闭会话是非常重要的，您应该要确保会话在一个 finally 块中被关闭。

```java
SqlSession session = sqlSessionFactory.openSession();
try{
    //do work
}finally{
    session.close();
}
```

在您的代码里都使用这一模式将保证所有的数据库资源被正确地关闭（假如您没有把您自己的数据库连接传递 Mybatis 管理，这表明您希望自己管理连接）

 

**Mapper实例**

Mappers 是创建来绑定映射语句的接口，该 Mapper 实例是从 SqlSession 得到的．因此，**所有实例的作用域跟创建它的 SqlSession 一样**。但是， mapper 实例**最好的作用域是 method**，也就是它们应该在方法内被调用，使用完即被毁。并且 mapper 实例不用显式地被关闭。虽然把 mapper 实例保持在一个 request 范围（与 SqlSession 相似）不会产生太大的问题，但是您可能会发现，在这个层次上管理太多资源可能会失控。保持简单，就是让 mapper 保持在一个方法内。下面的例了演示了这种做法。

```java
SqlSession session = sqlSessionFactory.openSession();
try{
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    //do work
}finally{
    session.close();
}
```



## mybatis 中 #{}和 ${}的区别是什么？

1）#{} 为参数占位符 ?，即sql 预编译；

2）${} 为字符串替换，即 sql 拼接；



2）能用 #{} 的地方就用 #{}，不用或少用 ${}

  

表名作参数时，必须用 ${}。如：select * from ${tableName}

  

order by 时，必须用 ${}。如：select * from t_user order by ${columnName}

  

使用 ${} 时，要注意何时加或不加单引号，即 ${} 和 '${}'






## mybatis 有几种分页方式？

## RowBounds 是一次性查询全部结果吗？为什么？

## mybatis 逻辑分页和物理分页的区别是什么？



## mybatis 是否支持延迟加载？延迟加载的原理是什么？

**范围**：

Mybatis仅支持**association关联对象和collection关联集合对象**的延迟加载，

association指的就是一对一，collection指的就是一对多查询。

在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

**原理**：

![1572495943352](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572495943352.png)

![1572495985363](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572495985363.png)



它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

**缺点**：

在按需加载时会多次连接数据库，同时会增加数据库的压力。



## 说一下 mybatis 的一级缓存和二级缓存？

![1572496130256](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572496130256.png)



mybatis默认支持一级缓存，无需配置；一级缓存的作用域默认是一个SqlSession；

一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果不想使用一级缓存，可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper中的语句后都会将一级缓存清除。
如果需要更改一级缓存的范围，可以在Mybatis的配置文件中，在下通过localCacheScope指定。

**需要注意的是**
当Mybatis整合Spring后，直接通过Spring注入Mapper的形式，如果不是在同一个事务中每个Mapper的每次查询操作都对应一个全新的SqlSession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个SqlSession。

二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享。

![1572496209610](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572496209610.png)

![1572496248954](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572496248954.png)

![1572496272565](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572496272565.png)





## mybatis 和 hibernate 的区别有哪些？

  **开发方面**

​        在项目开发过程当中，就速度而言：

​            hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；

​            Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；

​        但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，发杂语句较多，选择hibernate 就不是一个好方案。

​    **sql优化方面**

​        Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；

​        Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；

​    **对象管理比对**

​        Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；

​        Mybatis 需要自行管理 映射关系；



## mybatis 有哪些执行器（Executor）？

Mybatis有三种基本的Executor执行器:

​           **SimpleExecutor、ReuseExecutor、BatchExecutor。**  

**SimpleExecutor：**每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

**ReuseExecutor：**执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

**BatchExecutor：**执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。

作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。

Mybatis中如何指定使用哪一种Executor执行器？

答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。



## mybatis 分页插件的实现原理是什么？

mybatis page helper插件，他本身是一个物理分页插件，实际原理就是修改最后的执行sql，增加xi相应的分页内容，是基于拦截器实现的。

## mybatis 如何编写一个自定义插件？

对四大对象和插件有了一定了解后，这里我就开始简单实现一个自定义插件，来拦截四大对象，实现拦截器功能。
步骤：

1. 编写Interceptor的实现类
2. 使用@Intercepts注解完成插件签名 说明插件的拦截四大对象之一的哪一个对象的哪一个方法
3. 将写好的插件注册到全局配置文件中

编写Interceptor的实现类（dao层）以及注解声明
注解参数：

- type：拦截对象（四大对象之一）
- method：拦截对象的方法
- args：当前方法的参数列表

编写Interceptor的实现类：

```java
@Intercepts({
  @Signature(type=StatementHandler.class,method="parameterize",args=java.sql.Statement.class)
})
public class MyfirstPlugin implements Interceptor {
/**
 * 拦截目标对象的目标方法的执行；
 */
@Override
public Object intercept(Invocation invocation) throws Throwable {
    // TODO Auto-generated method stub
    System.out.println("要拦截的方法"+invocation+invocation.getMethod());
    Object prObject = invocation.proceed();
    return prObject;
}

/**
 * 包装目标对象的：包装：为目标对象创建一个代理对象
 */
@Override
public Object plugin(Object target) {
    // TODO Auto-generated method stub
    System.out.println("包装的对象"+target.toString());
    Object wrap = Plugin.wrap(target, this);
    return wrap;
}

/**
 * setProperties：
 *      将插件注册时 的property属性设置进来
 */
@Override
public void setProperties(Properties properties) {
    // TODO Auto-generated method stub
    System.out.println(properties);
}
}
```

全局配置文件：

```java
<plugins>
    <plugin interceptor="dao.MyfirstPlugin">
    <property name="root" value="jjc"/>
    <property name="pwdword" value="123456"/>
    </plugin>
</plugins>  
```



注意：
如果是 两个不同的插件对同一个对象的同一个方法进行拦截的时候
第一个插件的plugin方法的参数是未包装对象
第二个插件的plugin方法的参数是第一个插件包装后的对象

举一个栗子：当你查询id为2的内容 结果显示id为4的内容
查看id内容存放位置：
包装的对象org.apache.ibatis.executor.statement.RoutingStatementHandler@7c541c15
根据以上的内容知道创建的StatementHandler接口实现类是RoutingStatementHandler 是中间类
然后 找到这个类 ：默认是PREPARED

```java
case PREPARED:
        delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        再进入PreparedStatementHandler类：
         @Override
  public void parameterize(Statement statement) throws SQLException {
    parameterHandler.setParameters((PreparedStatement) statement);
  }

  parameterHandler是BaseStatementHandler的属性
  相当于parameterHandler是PreparedStatementHandler的属性
```



这个接口实现类是：DefaultParameterHandler

**DefaultParameterHandler类中属性：**

  Object parameterObject封装的就是参数值
  MappedStatement mappedStatement封装当前对象的增删改查详细信息的
  BoundSql boundSql封装sql的详细信息的

编写截目标对象的目标方法的执行：

```java
 @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // TODO Auto-generated method stub
        System.out.println("要拦截的方法"+invocation+invocation.getMethod());
        //得到当前对象
        Object target = invocation.getTarget();
        System.out.println("拦截的对象："+target);
        //拿到：StatementHandler==>ParameterHandler===>parameterObject
        //拿到target的元数据
        MetaObject metaobject = SystemMetaObject.forObject(target);
        Object value = metaobject.getValue("parameterHandler.parameterObject");
        System.out.println("当前参数值："+value);
        //修改完sql语句要用的参数
        metaobject.setValue("parameterHandler.parameterObject", 4);
        //执行原来的方法
        Object prObject = invocation.proceed();
        return prObject;
    }

```

 





# 十六、Zookeeper

## zookeeper 是什么？

## zookeeper 都有哪些功能？

## zookeeper 有几种部署模式？

## zookeeper 怎么保证主从节点的状态同步？

## 集群中为什么要有主节点？

## 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

## 说一下 zookeeper 的通知机制？

# 十七、数据库

## 数据库的三范式是什么？

第一范式：当关系模式R的所有**属性都不能在分解为更基本的数据单位**时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要

求，否则，将有很多基本操作在这样的关系模式中实现不了。

第二范式：如果关系模式R满足第一范式，并且**R的所有非主属性都完全依赖于R的每一个候选关键属性**，称R满足第二范式，简记为2NF。

第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果**X非传递依赖于R的任意一个候选关键字**，称R满足第三范式，简记为3NF.

**注：**关系实质上是一张二维表，其中每一行是一个元组，每一列是一个属性

 z

## 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

## 如何获取当前数据库版本？

## 说一下 ACID 是什么？

![1573102497300](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573102497300.png)

## char 和 varchar 的区别是什么？

## float 和 double 的区别是什么？

## mysql 的内连接、左连接、右连接有什么区别？

## mysql 索引是怎么实现的？

## 怎么验证 mysql 的索引是否满足需求？

## 说一下数据库的事务隔离？

https://baijiahao.baidu.com/s?id=1611918898724887602&wfr=spider&for=pc

## 说一下 mysql 常用的引擎？

## 说一下 mysql 的行锁和表锁？

## 说一下乐观锁和悲观锁？

## mysql 问题排查都有哪些手段？

## 如何做 mysql 的性能优化？

# 十八、Redis

## redis 是什么？都有哪些使用场景？

Redis是一个开源的key—value型数据库，支持string、list、set、zset和hash类型数据。对这些数据的操作都是原子性的，redis为了保证效率会定期持久化数据。

1. 配合关系型数据库做高速缓存

- 缓存高频次访问的数据，降低数据库io
- 分布式架构，做session共享

1. 可以持久化特定数据。

- 利用zset类型可以存储排行榜
- 利用list的自然时间排序存储最新n个数据

1. 端口：6379
2. **默认16个数据库，下标从0开始**
3. **单线程：redis是单线程+io多路复用：检查文件描述的就绪状态**

**Memchached：多线程+锁**



## redis 有哪些功能？



## redis 和 memecache 有什么区别？

## redis 为什么是单线程的？

## 什么是缓存穿透？怎么解决？

## redis 支持的数据类型有哪些？

redis支持的五种数据类型：

1、string（字符串）

2、hash（哈希）

　　Redis hash 是一个键值(key=>value)对集合。
　　Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

3、list（列表）

　　Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

4、set（集合）

　　Redis的Set是string类型的无序集合。

5、zset(sorted set：有序集合)

　　Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
　　不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
　　zset的成员是唯一的,但分数(score)却可以重复。

## redis 支持的 java 客户端都有哪些？

Jedis：

- 轻量，简洁，便于集成和改造
- 支持连接池
- 支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster
- 不支持读写分离，需要自己实现
- 文档差（真的很差，几乎没有……）

## jedis 和 redisson 有哪些区别？

## 怎么保证缓存和数据库数据的一致性？

## redis 持久化有几种方式？

## redis 怎么实现分布式锁？

## redis 分布式锁有什么缺陷？

## redis 如何做内存优化？

## redis 淘汰策略有哪些？

## redis 常见的性能问题有哪些？该如何解决？

# 十九、JVM

## 说一下 jvm 的主要组成部分？及其作用？

![img](https://upload-images.jianshu.io/upload_images/5984812-ecc8232f74040390.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**class loader 类加载器**：加载类文件到内存。Class loader只管加载，只要符合文件结构就加载，至于能否运行，它不负责，那是有Exectution Engine 负责的。

**exection engine** ：执行引擎也叫解释器，负责解释命令，交由操作系统执行。

**native interface**：本地接口。本地接口的作用是融合不同的语言为java所用。

**Runtimedata  area 运行数据区**：运行数据区是jvm的重点，我们所有所写的程序都被加载到这里，之后才开始运行。

- stack：栈也叫栈内存，是java程序的运行区，是在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存释放；对于栈来说不存在垃圾回收的问题，只要线程一结束，该栈就结束。栈中的数据以栈帧的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的集合，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。
- 堆内存：一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类的加载器读取了类文件之后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分三部分：永久存储（用于存放jdk自身携带的class,interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收掉的，只有关闭jvm释放此区域所占用的内存）区、新生区、老年代
- method area方法区：方法去是被所有线程共享，该区域保存的所有字段和字节方法码以及一些特殊方法如构造函数，接口代码也在此定义。
- **PC Register 程序计数器：每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令**





## 说一下 jvm 运行时数据区？

![JVMåå­åºå](https://img-blog.csdn.net/20180419222132924?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NDk5NjE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**堆**：

 堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，**JDK1.7后，运行时常量池（例String.intern()）从方法区移到了堆上**。

​	**运行时常量池：**

- 在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。
- 在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。
- 在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。

**方法区**：

它用于存储已被**虚拟机加载的类信息，常量，静态变量**，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。

在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。

jdk1.8：仍然保留方法区的概念，只不过实现方式不同。取消永久代，方法存放于**元空间(Metaspace)**，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中。

1）移除了永久代（PermGen），替换为元空间（Metaspace）；
2）永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
3）永久代中的字符串常量池（ interned Strings ）和 类的静态变量（class static variables） 转移到了 Java heap；
4）永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）。

**虚拟机栈**：

虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法返回地址等信息。

**本地方法栈**：

与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，**本地方法栈为虚拟机使用的Native方法服务**，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法返回地址等信息。

**程序计数器**：

指示Java虚拟机下一条需要执行的字节码指令。

以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区供类对象之间共享，**虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有**的，不会与其他线程共享。
所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。





## 说一下堆栈的区别？

**堆（heap）：**

堆是一种经过排序的**树形数据结构**，每个结点都有一个值。

**栈（stack）：**

它是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。

**1，申请方式**

heap：程序员自己申请，并指明大小。

stack：由系统分配。

**2，申请效率**

**原为：**

heap：效率较高，速度较快，但程序员无法对其进行控制。

stack：由new分配的内存，相对效率和速度都较低，且容易产生碎片，但由于是程序员自己申请操作，灵活性强，使用方便。

**3，存储的数据类型**

heap：存储引用类型

stack：存储值类型，即存储固定长度的数据。比如：整数、字符、结构、布尔、枚举等。每个程序在执行时都有自己的堆栈，其他程序不能访问该堆栈。

**三、相关名词**

**1，压栈（进栈、入栈）：**用push表示，就是把数据放入栈中，从栈顶放入，有先进后出的特点！

**2，清栈**：清空栈中所有的数据。

**3，出栈：**用POP表示，它是和压栈相反的概念，即把数据从栈中取出来。出栈时从栈顶取出。



## 队列和栈是什么？有什么区别？

**队列**（Queue）：是限定只能在表的一端进行插入和另一端删除操作的**线性表**；
**栈**（Stack）：是限定之能在表的一端进行插入和删除操作的**线性表**；

**队列和栈的规则**：
队列：先进先出；
栈：先进后出；

队列和栈的遍历数据速度

队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在**遍历的过程中不影响数据结构**，所以遍历速度要快；
栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，**遍历数据时需要微数据开辟临时空间**，保持数据在遍历前的一致性；

## 什么是双亲委派模型？

**Java虚拟机先从最核心的API开始查找，防止不可信的类扮演被信任的类。**

 **双亲委派模型**：

双亲委派模型要求**除顶层启动类加载器**外其余类加载器都应该有自己的父类加载器；类加载器之间通过复用关系来复用父加载器的代码。



**双亲委派模型工作工程**：

1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。  

2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。  

3.如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。  

4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。  

5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。  

6.如果均加载失败，就会抛出ClassNotFoundException异常。 



 **双亲委派模型的实现过程**：

实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中：  

首先会检查请求加载的类是否已经被加载过；  

若没有被加载过：  

递归调用父类加载器的loadClass();  

父类加载器为空后就使用启动类加载器加载；  

如果父类加载器和启动类加载器均无法加载请求，则调用自身的加载功能。



**双亲委派模型的优点**：

Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。  

保证了运行的安全性，防止不可信类扮演可信任的类。

例如类`java.lang.Object`，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对`java.lang.Object`的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此**Object类在程序的各种类加载器环境中都是同一个类**。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。



## 说一下类加载的执行过程？

![img](https://upload-images.jianshu.io/upload_images/14265221-905453ee556fc809.png?imageMogr2/auto-orient/strip|imageView2/2/w/938/format/webp)



1、**加载**

将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。

2、**链接**

将Java类的二进制代码合并到JVM的运行状态之中。

**• 验证**
 确保加载的类信息符合JVM规范，没有安全方面的问题。
 **• 准备**
 正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些**内存**都将在方法区中进行**分配**。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。
 **• 解析**
 虚拟机常量池内的**符号引用**替换为直接引用（地址引用）的过程。

3、**初始化**

初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的**赋值**动作和**静态语句块(static块)**中的语句合并产生的。

- 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。



**Java程序初始化顺序**：

1、父类的静态变量
 2、父类的静态代码块
 3、子类的静态变量
 4、子类的静态代码块
 5、父类的非静态变量
 6、父类的非静态代码块
 7、父类的构造方法
 8、子类的非静态变量
 9、子类的非静态代码块
 10、子类的构造方法





## 怎么判断对象是否可以被回收？

**1.引用计数算法**

java在运行时，当有一个地方引用该对象实例，会将这个对象实例加1，引用失效时就减1，jvm在扫描内存时，发现引用计数值为0的则是垃圾对象，计数值大于0的则为活跃对象。

目前垃圾回收算法，没有采用引用计数算法，原因是在对象互相引用的情况下，无法判定两者是否为垃圾对象。

**2.根搜索算法**

根搜索算法是以“GC ROOTS”为起始点往下搜索，所有经过的对象合并起来称为引用链，在这引用链里，没有的对象称为垃圾对象，（实际上jvm还做了一个筛选动作，判定当前对象是否执行finalize()方法，如果不需要执行才判定为垃圾对象，这里不做介绍），在引用链里的是活跃对象。那什么样的对象才能称为“GC ROOTS”呢？以下四种可以

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
2. 方法区中的类静态属性引用的对象。
3. 方法区中的常量引用的对象。
4. 本地方法栈中 JNI（Native 方法）的引用对象。



## java 中都有哪些引用类型？

1. 强引用（Strong Reference）；
2. 软引用（Soft Reference）；
3. 弱引用（Weak Reference）；
4. 虚引用（Phantom Reference）；

一，**强引用**

Java中默认声明的就是强引用，比如：

```
Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收
obj = null;  //手动置null
```

只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了；

二，**软引用**

软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。
在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。

下面以一个例子来进一步说明强引用和软引用的区别：
在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。

首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常

```java
public class TestOOM {
    
    public static void main(String[] args) {
         testStrongReference();
    }
    private static void testStrongReference() {
        // 当 new byte为 1M 时，程序运行正常
        byte[] buff = new byte[1024 * 1024 * 1];java
    }
}
```

但是如果我们将

```java
byte[] buff = new byte[1024 * 1024 * 1];
```

替换为创建一个大小为 2M 的字节数组

```java
byte[] buff = new byte[1024 * 1024 * 2];
```

则内存不够使用，程序直接报错，强引用并不会被回收
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194052676-1646914311.png)

接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。

```java
public class TestOOM {
    private static List<Object> list = new ArrayList<>();
    public static void main(String[] args) {
         testSoftReference();
    }
    private static void testSoftReference() {
        for (int i = 0; i < 10; i++) {
            byte[] buff = new byte[1024 * 1024];
            SoftReference<byte[]> sr = new SoftReference<>(buff);
            list.add(sr);
        }
        
        System.gc(); //主动通知垃圾回收
        
        for(int i=0; i < list.size(); i++){
            Object obj = ((SoftReference) list.get(i)).get();
            System.out.println(obj);
        }
        
    }
    
}
```

打印结果：
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194016719-117632363.png)

我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。
这里就说明了**在内存不足的情况下，软引用将会被自动回收。**
值得注意的一点 , 即使有 byte[] buff 引用指向对象, 且 buff 是一个strong reference, 但是 SoftReference sr 指向的对象仍然被回收了，这是因为Java的编译器发现了在之后的代码中, buff 已经没有被使用了, 所以自动进行了优化。
如果我们将上面示例稍微修改一下：

```java
    private static void testSoftReference() {
        byte[] buff = null;

        for (int i = 0; i < 10; i++) {
            buff = new byte[1024 * 1024];
            SoftReference<byte[]> sr = new SoftReference<>(buff);
            list.add(sr);
        }

        System.gc(); //主动通知垃圾回收
        
        for(int i=0; i < list.size(); i++){
            Object obj = ((SoftReference) list.get(i)).get();
            System.out.println(obj);
        }

        System.out.println("buff: " + buff.toString());
    }
```

则 buff 会因为强引用的存在，而无法被垃圾回收，从而抛出OOM的错误。
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194030314-105853688.png)

如果一个对象惟一剩下的引用是软引用，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。



三，**弱引用**

弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。
我们以与软引用同样的方式来测试一下弱引用：

```java
    private static void testWeakReference() {
        for (int i = 0; i < 10; i++) {
            byte[] buff = new byte[1024 * 1024];
            WeakReference<byte[]> sr = new WeakReference<>(buff);
            list.add(sr);
        }
        
        System.gc(); //主动通知垃圾回收
        
        for(int i=0; i < list.size(); i++){
            Object obj = ((WeakReference) list.get(i)).get();
            System.out.println(obj);
        }
    }
```

打印结果：
![img](https://img2018.cnblogs.com/blog/662236/201809/662236-20180922194112309-477100844.png)

可以发现所有被弱引用关联的对象都被垃圾回收了。

四，**虚引用**

虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

```java
public class PhantomReference<T> extends Reference<T> {
    /**
     * Returns this reference object's referent.  Because the referent of a
     * phantom reference is always inaccessible, this method always returns
     * <code>null</code>.
     *
     * @return  <code>null</code>
     */
    public T get() {
        return null;
    }
    public PhantomReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
```

那么传入它的构造方法中的 ReferenceQueue 又是如何使用的呢？



五，引用队列（ReferenceQueue）

引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

与软引用、弱引用不同，虚引用必须和引用队列一起使用。



 

## 说一下 jvm 有哪些垃圾回收算法？

![img](https://pics7.baidu.com/feed/5fdf8db1cb1349542e598558355e2c5cd1094a5f.jpeg?token=218f83050952c04d3f92d3dda8223ef5&s=76B9E76A4102235B4A69373E0200D044)





**垃圾回收算法**

**1. 标记-清除（Mark-Sweep）**

![img](https://pics7.baidu.com/feed/96dda144ad345982e2eb2f9c6de48fa9cbef8474.jpeg?token=70630aeaf94ebdb90bfc21c329e98b29&s=3A8DB74A4F5636CA5C91C72A02007057)标记清除流程

jvm会扫描所有的对象实例，通过根搜索算法，将活跃对象进行标记，jvm再一次扫描所有对象，将未标记的对象进行清除，只有清除动作，不作任何的处理，这样导致的结果会存在很多的内存碎片。

**2. 复制（copying）**

![img](https://pics3.baidu.com/feed/cdbf6c81800a19d854ca145852ea3c8fa71e46b3.jpeg?token=85f861561616794c19b3e4c2346418a3&s=1E0DA74281A287115CB0C73502002057)复制流程

jvm扫描所有对象，通过根搜索算法标记被引用的对象，之后会申请新的内存空间，将标记的对象复制到新的内存空间里，存活的对象复制完，会清空原来的内存空间，将新的内存最为jvm的对象存储空间。这样虽然解决了内存内存碎片问题，但是如果对象很多，重新申请新的内存空间会很大，在内存不足的场景下，会对jvm运行造成很大的影响

**3. 标记-整理（Mark-compact）**

![img](https://pics2.baidu.com/feed/1ad5ad6eddc451dae5ef6cc2d7edec62d0163296.jpeg?token=ba6c34d81bd5bce554b178cf21b8b8cc&s=FEA9F74A4FD636CA5C99C72A02006057)标记整理流程

标记整理实际上是在标记清除算法上的优化，执行完标记清除全过程之后，再一次对内存进行整理，将所有存活对象统一向一端移动，这样解决了内存碎片问题。

**4. 分代回收**

![img](https://pics4.baidu.com/feed/d788d43f8794a4c2f657f51d6fe4a5d1ad6e39a0.jpeg?token=ef120b2780bb2a13e34554081d75de9a&s=9382F34A3FC81D6444AA4B0B020070D8)分代回收算法

目前jvm常用回收算法就是分代回收，年轻代以复制算法为主，老年代以标记整理算法为主。原因是年轻代对象比较多，每次垃圾回收都有很多的垃圾对象回收，而且要尽可能快的减少生命周期短的对象，存活的对象较少，这时候复制算法比较适合，只要将有标记的对象复制到另一个内存区域，其余全部清除，并且复制的数量较少，效率较高；而老年代是年轻代筛选出来的对象，被标记比较高，需要删除的对象比较少，显然采用标记整理效率较高。





## 说一下 jvm 有哪些垃圾回收器？

serial收集器、parnew收集器、parallel scavenge收集器、serial  old 收集器、parallel old收集器、cms收集器、g1收集器

**下图解HotSpot虚拟机所包含的收集器：**

![img](https://img2018.cnblogs.com/blog/1326194/201810/1326194-20181017145352803-1499680295.png)

## 详细介绍一下 CMS 垃圾回收器？



## 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？

**新生代收集器**：Serial、ParNew、Parallel Scavenge

**老年代收集器**：CMS、Serial Old、Parallel Old

**整堆收集器**： G1

JDK8默认使用的垃圾收集器： Parallel Scavenge + Parallel Old；

**并行收集**：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。

**并发收集**：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。

**吞吐量**：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%



## 简述分代垃圾回收器是怎么工作的？

**新生代** - 刚创建的对象，在代码运行时一般都会持续不断地创建新的对象，这些新创建的对象有很多是局部变量，很快就会变成垃圾对象。这些对象被放在一块称为新生代的内存区域。新生代的特点是垃圾对象多，存活对象少。

**老年代** - 一些对象很早被创建了，经历了多次GC也没有被回收，而是一直存活下来。这些对象被放在一块称为老年代的区域。老年代的特点是存活对象多，垃圾对象少。

**永久代** - 一些伴随虚拟机生命周期永久存在的对象，比如一些静态对象，常量等。这些对象被放在一块称为永久代的区域。永久代的特点是这些对象一般不需要垃圾回收，会在虚拟机运行过程中一直存活。（在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。）

分代收集算法也就根据**新生代和老年代**来进行垃圾回收的。

对于新生代区域，每次GC都会有很多垃圾对象被回收，只有少量存活。因此采用**复制回收算法**，GC时把剩余很少的存活对象复制过去即可。

在新生代区域中，并不是按照1:1的比例来进行复制回收，而是按照**8:1:1的比例分为了Eden、SurvivorA、SurvivorB**三个区域。其中Eden意为伊甸园，形容有很多新生对象在里面创建；Survivor区则为幸存者，即经历GC后仍然存活下来的对象。

Eden区对外提供堆内存。当Eden区快要满了，则进行Minor GC(新生代GC)，把存活对象放入SurvivorA区，清空Eden区；

Eden区被清空后，继续对外提供堆内存；

当Eden区再次被填满，此时对Eden区和SurvivorA区同时进行Minor GC(新生代GC)，把存活对象放入SurvivorB区，此时同时清空Eden区和SurvivorA区；

Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；

当某个Survivor区被填满，且仍有对象未被复制完毕时，**或者某些对象在反复Survive 15次**左右时，则把这部分剩余对象放到老年代区域；当老年区也被填满时，进行Major GC（老年代GC），对老年代区域进行垃圾回收。

老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，因此采用**标记-整理算法，GC时移动少量存活对象，不会产生内存碎片。**





## 说一下 jvm 调优的工具？



## 常用的 jvm 调优的参数都有哪些？





# 二十、微服务

## 什么是微服务？

就目前而言，对于微服务，业界并没有一个统一的、标准的定义；

**微服务**：

强调的是服务的大小，关注的是某一个点，是具体解决某一问题/提供对应落地服务的一个服务应用；



**微服务架构**：

但通常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的自己的行程中，服务之间互相协调、互相配合，为用户提供最终价值；

服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。

每个服务都围绕具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。

另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，可可以使用不同的数据存储。

## 微服务之间是如何独立通讯的？



## SpringCloud和Dubbo有哪些区别？

**最大区别：服用调用方式**

SpringCloud采用基于HTTP的REST方式虽然从一定程度上说，牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。

而且REST比RPC更为灵活，服务提供方和调用方的依赖只依靠契约，不存在代码级别的强依赖，这在强调代码快速演化的微服务环境中，显得更加合适。

而且SpringCloud是一站式解决方案，而Dubbo需要依赖其他组件；



Dubbo RPC远程过程调用；

SpringCloud是Restful调用

|              | Dubbo         | SpringCloud                 |
| ------------ | ------------- | --------------------------- |
| 服务注册方式 | Zookeeper     | SpringCloud Netflix Eureka  |
| 服务调用方式 | RPC           | RESTFUL API                 |
| 服务监控     | Dubbo-monitor | SpringBoot Admin            |
| 断路器       | 不完善        | SpringCloud Netflix Hystrix |
| 服务网关     | 无            | SpringCloud Netflix Zuul    |
| 分布式配置   | 无            | SpringCloud Config          |
| 服务跟踪     | 无            | SpringCloud Sleuth          |
| 消息总线     | 无            | SpringCloud Bus             |
| 数据流       | 无            | SpringCloud Stream          |
| 批量任务     | 无            | SpringCloud Task            |



## SpringBoot和SpringCloud，谈谈对他们的理解？

Springboot专注于开发个体单个微服务；

SpringCloud关注全局的微服务协调整理治理框架，它将Springboot开发的一个个单体微服务整合并管理起来；



## 什么是服务熔断，什么是服务降级？

## 微服务的优缺点分别是什么？说下在项目中遇到的坑？

**优点**：

服务足够内聚，小，代码容易理解，可以聚焦到一个指定的业务功能或者业务需求；

开发简单，开发效率高；

可以被小团队单独开发；

微服务是松耦合的，是有功能意义的服务，无论是在开发阶段还是部署阶段都是独立的；

微服务可以使用不同的语言开发；

易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins，Hudson，bamboo。

微服务只是业务逻辑的代码，不会其他界面组件混合；

每个微服务都可以连接自己的数据库，可以一起，也可以分开；

**缺点**：

要处理分布式系统的复杂性；

多服务运维难度，随着服务的增加，运维的压力也增大；

系统部署依赖；

服务间通信成本；

数据一致性；

系统集成测试；

性能监控；





## 所知道的微服务技术栈有哪些？请举例一二？

**微服务技术栈**：

多种技术集合体；

| 微服务条目                               | 落地技术                                                     | 备注 |
| ---------------------------------------- | ------------------------------------------------------------ | ---- |
| 服务开发                                 | Springboot、Spring、SpringMVC                                |      |
| 服务配置与管理                           | Netflix公司的Archaius、阿里的Diamond等                       |      |
| 服务注册与发现                           | Eureka、Consul、Zookeeper等                                  |      |
| 服务调用                                 | Rest、RPC、gRPC等                                            |      |
| 服务熔断器                               | Hystrix、Envoy等                                             |      |
| 负载均衡                                 | Ribbon、Nginx等                                              |      |
| 服务接口调用（客服端调用服务的简化工具） | Feign                                                        |      |
| 消息队列                                 | Kafka、RabbITMQ、ActiveMQ等                                  |      |
| 服务配置中心管理                         | SpringCloudConfig、Chef等                                    |      |
| 服务路由（API）网关                      | Zuul等                                                       |      |
| 服务监控                                 | Zabbix、Nagios、Metrics、Spectator等                         |      |
| 全链路追踪                               | Zipkin、Brave、Dapper等                                      |      |
| 服务部署                                 | Docker、OpenStack、Kubernetes等                              |      |
| 数据流操作开发包                         | SpringCloud Stream （封装与Redis、Rabbit、 Kafka等发送接收消息） |      |
| 事件消息总栈                             | SpringCloud Bus                                              |      |

| 功能点/服务框架 | Netflix/Spring Cloud                                         | Motan                                                        | gRPC                      | Thrift   | Dubbo/DubboX     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- | -------- | ---------------- |
| 功能定位        | 完整的微服务框架                                             | RPC框架但整合了Consul或者ZK，实现集群环境的基本的服务注册/发现 | RPC框架                   | RPC框架  | 服务框架         |
| 支持Rest        | 是，Ribbon支持多种可插拔的序列化选择                         | 否                                                           | 否                        | 否       | 否               |
| 支持RPC         | 否                                                           | 是（Hession2）                                               | 是                        | 是       | 是               |
| 支持多语言      | 是                                                           | 否                                                           | 是                        | 是       | 否               |
| 服务注册/发现   | 是Eureka，Eureka是服务注册表，Karyon服务端框架支持服务自注册和健康检查 | 是Zookeeper/consul                                           | 否                        | 否       | 是               |
| 负载均衡        | 是（服务端zuul+客户端Ribbon） zuul-服务，动态路由  云端负载均衡Eureka针对中间层服务器 | 是客户端                                                     | 否                        | 否       | 是客户端         |
| 配置服务        | Netflix Archaius SpringCloud Config Server集中配置           | 是Zookeeper提供                                              | 否                        | 否       | 否               |
| 服务调用链监控  | 是zuul，Zuul提供边缘服务，API网关                            | 否                                                           | 否                        | 否       | 否               |
| 高可用/容错     | 是服务端Hystrix和客户端Robbon                                | 是客户端                                                     | 否                        | 否       | 是客户端         |
| 典型应用案例    | Netflix                                                      | Sina                                                         | Google                    | Facebook |                  |
| 社区活跃程度    | 高                                                           | 一般                                                         | 高                        | 一般     | 已经不维护了     |
| 学习难度        | 中等                                                         | 低                                                           | 高                        | 高       | 低               |
| 文档丰富度      | 高                                                           | 一般                                                         | 一般                      | 一般     | 高               |
| 其他            | SpringCloud Bus为应用程序带来了更多管理端点                  | 支持降级                                                     | Netflix内部在开发集成gRPC | IDL定义  | 实践的公司比较多 |





## eureka和zookeeper都可以提供服务注册和发现的功能，请说说两个的区别？

由于分区容错性（P）是在分布式系统中必要要保证的，因此只能在C和A之间权衡；

Zookeeper保证的是CP；

Eureka保证的是AP；

**Zookeeper保证的是CP：**

当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说服务注册功能对可用性的要求大于一致性。

但是ZK会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于选举leader的时间太长，30~120s且选举期间整个ZK集群都不可用，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得ZK集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是无法容忍的。

**Eureka保证的是AP：**

Eureka在设计上优先保证可用性。Eureka各个节点都是平等的，几个节点的挂掉不会影响正常节点的工作，剩余的节点依旧可以提供注册和查询服务。

而Eureka的客户端在向Eureka注册时如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka在，就能保证注册服务可用（保证高可用性），只不过查到的信息可能不是最新的（不保证强一致性）。

除此之外，Eureka还要一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：

1. Eureka不再从注册列表中移除因为长时间没收到心跳应该过期的服务；
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）；
3. 当网络稳定时，当前实例新的注册信息会被同步到其他节点；

因此，Eureka可以很好的应对因网络故障导致的部分节点失去联系的故障，而不像Zookeeper那样会使整个注册服务瘫痪。







## Eureka

Eureka是Netflix的子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件。功能类似于dubbo的注册中心，比如Zookeeper。

Eureka采用了C-S的设计架构。Eureka server作为服务注册功能的服务器，他是服务注册中心。

而系统的中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳。这样系统的维护人员就可以通过Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud的一些其他模块（比如Zuul）就可以通过Eureka Server来发现系统中的其他微服务，并执行相关的逻辑。

![1573048775470](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573048775470.png)

![1573048788905](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573048788905.png)

Eureka包括两大组件：Eureka Server 和Eureka Client

Eureka Server提供服务注册服务，各个节点启动后，会在Eureka中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。

Eureka Client是一个客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳（默认周期为30s）。如果Eureka Server在多个心跳周期内没有收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除（默认90s）；

三大角色：Eureka Server、服务提供者、服务调用者；

Eureka的自我保护机制：

某时刻某个微服务不可用了，eureka不会立即清理，依旧会对该微服务的信息进行保存；

默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90s）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，以上行为可能变得非常危险——以为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当Eureka节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。

在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数重新恢复到阙值以上时，该Eureka Server节点就会自动退出自我保护模式。

综上，自我保护模式是一种应对网络异常的安全保护措施，它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲：好死不如赖活着。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。

在Spring Cloud中，可以在Eureka Server中使用eureka.server.enable-self-preservation = false 禁用自我保护模式。

## CAP

C：Consistency 强一致性；

A：Availability 高可用性；

P：Partition tolerance 分区容错性；

最多只能同时较好的满足两个：

CAP理论的核心是：

一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：

CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大；

CP：满足一致性，分区容忍性的系统，通常性能不是特别高；

AP：满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。



![1573103015555](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573103015555.png)

## Ribbon

Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端、负载均衡的工具；

简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。

Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。

**Load Balancer（简称LB）：**

在微服务或分布式集群中常用的一种应用。

负载均衡简单的来说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）；

常见的负载均衡有软件Nginx，LVS，硬件F5等。

相应的中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。

**集中式LB：**

即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方。

**进程内LB：**

将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

**Ribbon在工作时分成两步：**

第一步选择Eureka Server，优先选择在同一区域内负载较少的Server；

第二步再根据用户指定的策略，在从Server取到的服务注册列表中选择一个地址；

**IRule根据特定算法中从服务列表中选取一个要访问的服务：**

1. RoundRobinRule
   轮询

2. RandomRule
   随机

3. AvailabilithFilteringRule
   会先过滤由于多次访问故障而处于断路器跳闸状态的服务
   还要并发的连接数超过阙值的服务，
   然后对剩余的服务列表按照轮询策略进行访问。

4. WeightedResponseTimeRule
   根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。
   刚启动时如果统计信息不足，则使用轮询策略，等统计信息足够，再切换到此策略。

5. RetryRule
   先按照轮询策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务。

6. BestAvailableRule
   会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。

7. ZoneAvoidanceRule
   默认规则，复合判断server所在区域的性能和server的可用性选择服务器。

   ![1573132018091](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573132018091.png)

**Ribbon自定义负载均衡算法：**

配置类加*@RibbonClient(name="STUDY-SPRINGCLOUD-DEPT",configuration = MySelfRule.class)*

官方文档给出明确警告：

这个自定义配置类 MySelfRule.class不能放在@ComponentScan所扫描的当前包以及子包下，否则自定的这个配置类会被所有Ribbon客户端共享，也就达不到特殊化定制的目的了。

## Feign

Feign是一个声明式的Web服务客户端，使得编写Web服务客户端变得非常容易；

只需要创建一个接口，然后在上面添加注解即可。

**背景：**

Ribbon通过微服务名字获得调用地址；

目前大家都习惯面向接口编程，比如webservice接口，dao接口等，Feign就是通过接口加注解，获取调用服务。

**用途：**

Feign旨在使编写Java Http客户端变得更容易；

![1573185740925](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573185740925.png)



![1573186992141](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573186992141.png)

![1573187409030](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573187409030.png)

## Hystrix

**服务雪崩**：

多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩响应”。

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

**服务熔断**：

熔断机制是应对雪崩效应的一种微服务链路保护机制

当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回“错误“的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。

在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阙值，缺省是5s内20次调用失败就会启动熔断机制。

熔断机制的注解是*@HystrixCommand.*

```java
@EnableCircuitBreaker//对Hystrix熔断机制的支持
```

**服务降级：**

整体资源快不够了，忍痛将某些服务先关闭，待渡过难关，再开启。

服务降级是在客户端完成的，与服务端没有关系。	

**服务监控：**

出了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续的记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。

Netflix通过Hystrix-metrics-event-stream项目实现了对以上指标的监控。

SpringCloud也提供了Hystrx Dashboard的整合，对监控内容转化为可视化界面。



![1573203417983](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573203417983.png)



## Zuul



![1573203936517](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573203936517.png)



## SpringCloud-Config





SpringCloud Config分为服务端和客户端两部分。

![1573206244810](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573206244810.png)

![1573206285874](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573206285874.png)

![1573205927497](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573205927497.png)

![1573206132365](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573206132365.png)

![1573207367516](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573207367516.png)

![1573209276197](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573209276197.png)

![1573212312707](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1573212312707.png)

# 二十一、Maven

## Maven 是什么？

Maven 主要服务于基于 Java 平台的项目构建、依赖管理和项目信息管理。

Maven 的主要功能主要分为 5 点：

- 依赖管理系统
- 多模块构建
- 一致的项目结构
- 一致的构建模型和插件机制

 **Maven 规约是什么？**

- `/src/main/java/` ：Java 源码。
- `/src/main/resource` ：Java 配置文件，资源文件。
- `/src/test/java/` ：Java 测试代码。
- `/src/test/resource` ：Java 测试配置文件，资源文件。
- `/target` ：文件编译过程中生成的 `.class` 文件、jar、war 等等。
- `pom.xml` ：配置文件

## Maven 常用命令

- `mvn archetype：create` ：创建 Maven 项目。
- `mvn compile` ：编译源代码。
- `mvn deploy` ：发布项目。
- `mvn test-compile` ：编译测试源代码。
- `mvn test` ：运行应用程序中的单元测试。
- `mvn site` ：生成项目相关信息的网站。
- `mvn clean` ：清除项目目录中的生成结果。
- `mvn package` ：根据项目生成的 jar/war 等。
- `mvn install` ：在本地 Repository 中安装 jar 。
- `mvn eclipse:eclipse` ：生成 Eclipse 项目文件。
- `mvn jetty:run` 启动 Jetty 服务。
- `mvn tomcat:run` ：启动 Tomcat 服务。
- `mvn clean package -Dmaven.test.skip=true` ：清除以前的包后重新打包，跳过测试类。

## Maven 生命周期是怎么样的？

Maven 中有三个独立的生命周期：

- 1、Clean
- 2、Default
- 3、Site

Maven有三套相互独立的生命周期，分别是 Clean、Default 和 Site。每个生命周期包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段。

- 1、Clean 生命周期：清理项目，包含三个 phase ：
  - pre-clean：执行清理前需要完成的工作。
  - clean：清理上一次构建生成的文件。
  - post-clean：执行清理后需要完成的工作
- 2、Default 生命周期：构建项目，重要的 phase 如下：
  - validate：验证工程是否正确，所有需要的资源是否可用。
  - compile：编译项目的源代码。
  - test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。
  - package：把已编译的代码打包成可发布的格式，比如 jar、war 等。
  - integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。
  - verify：运行所有检查，验证包是否有效且达到质量标准。
  - install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。
  - deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。
- 3、Site 生命周期：建立和发布项目站点，phase 如下：
  - pre-site：生成项目站点之前需要完成的工作
  - site：生成项目站点文档
  - post-site：生成项目站点之后需要完成的工作
  - site-deploy：将项目站点发布到服务器

各个生命周期相互独立，一个生命周期的阶段前后依赖。

- `mvn clean` ：调用 Clean 生命周期的 clean 阶段，实际执行 pre-clean 和 clean 阶段
- `mvn test` ：调用 Default 生命周期的 test 阶段，实际执行 test 以及之前所有阶段
- `mvn clean install` ：调用 Clean 生命周期的 clean 阶段和 Default 生命周期 的 install 阶段，实际执行 pre-clean 和 clean ，install 以及之前所有阶段。

# 二十二、排序

冒泡排序：

```java
 //冒泡排序算法
        int[] numbers=new int[]{1,5,8,2,3,9,4};
        int i,j;
        for(i=0;i<numbers.length;i++)
        {
            for(j=0;j<numbers.length-1-i;j++)
            {
                if(numbers[j]<numbers[j+1])
                {
                    int temp=numbers[j];
                    numbers[j]=numbers[j+1];
                    numbers[j+1]=temp;
                }
            }
        }
```

直接插入排序：

```java
public static void insertionSort(int[] arr){
    for( int i=0; i<arr.length-1; i++ ) {
        for( int j=i+1; j>0; j-- ) {
            if( arr[j-1] <= arr[j] )
                break;
            int temp = arr[j];      //交换操作
            arr[j] = arr[j-1];
            arr[j-1] = temp;
            System.out.println("Sorting:  " + Arrays.toString(arr));
        }
    }
}
```

